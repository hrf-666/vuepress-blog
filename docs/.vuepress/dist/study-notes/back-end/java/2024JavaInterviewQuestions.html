<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2024版Java面试真题 | Rui</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/vuepress-blog/assets/img/logo.png">
    <link rel="manifest" href="/vuepress-blog/manifest.json">
    <link rel="apple-touch-icon" href="/vuepress-blog/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/vuepress-blog/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="点点滴滴">
    <meta name="referrer" content="no-referrer">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/vuepress-blog/assets/css/0.styles.9508d0de.css" as="style"><link rel="preload" href="/vuepress-blog/assets/js/app.708f652f.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/2.467e751d.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/1.cda9c0e5.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/142.3d30c6ee.js" as="script"><link rel="preload" href="/vuepress-blog/assets/js/59.8ba32256.js" as="script"><link rel="prefetch" href="/vuepress-blog/assets/js/10.20ceacbe.js"><link rel="prefetch" href="/vuepress-blog/assets/js/100.506b323f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/101.6bd40fa9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/102.5d6851eb.js"><link rel="prefetch" href="/vuepress-blog/assets/js/103.d1653323.js"><link rel="prefetch" href="/vuepress-blog/assets/js/104.11f58b8e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/105.2c7c5c65.js"><link rel="prefetch" href="/vuepress-blog/assets/js/106.114803a0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/107.1168154e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/108.b1d0e095.js"><link rel="prefetch" href="/vuepress-blog/assets/js/109.58227940.js"><link rel="prefetch" href="/vuepress-blog/assets/js/11.368420d2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/110.d344f22f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/111.acbd146a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/112.84544da2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/113.cde653ae.js"><link rel="prefetch" href="/vuepress-blog/assets/js/114.68590f3b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/115.37fc580b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/116.b77d20d2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/117.c85fd8de.js"><link rel="prefetch" href="/vuepress-blog/assets/js/118.8cc76244.js"><link rel="prefetch" href="/vuepress-blog/assets/js/119.832bfef2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/12.84a376f3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/120.cbaac5cd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/121.27ff69f2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/122.3fbd0f98.js"><link rel="prefetch" href="/vuepress-blog/assets/js/123.0d140807.js"><link rel="prefetch" href="/vuepress-blog/assets/js/124.94ff4257.js"><link rel="prefetch" href="/vuepress-blog/assets/js/125.859dcee6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/126.8478ba08.js"><link rel="prefetch" href="/vuepress-blog/assets/js/127.082e0f90.js"><link rel="prefetch" href="/vuepress-blog/assets/js/128.c39cfb3e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/129.fbb8e714.js"><link rel="prefetch" href="/vuepress-blog/assets/js/13.20704b9e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/130.b87c3a84.js"><link rel="prefetch" href="/vuepress-blog/assets/js/131.6af138f9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/132.ce7d53c9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/133.e9d4b3bb.js"><link rel="prefetch" href="/vuepress-blog/assets/js/134.7d0e406a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/135.881e2052.js"><link rel="prefetch" href="/vuepress-blog/assets/js/136.18420808.js"><link rel="prefetch" href="/vuepress-blog/assets/js/137.4ed93e54.js"><link rel="prefetch" href="/vuepress-blog/assets/js/138.89e6323b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/139.9f768644.js"><link rel="prefetch" href="/vuepress-blog/assets/js/14.e7fc696a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/140.985935ed.js"><link rel="prefetch" href="/vuepress-blog/assets/js/141.8d4002fa.js"><link rel="prefetch" href="/vuepress-blog/assets/js/143.5c3aa373.js"><link rel="prefetch" href="/vuepress-blog/assets/js/144.6f91183b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/145.d931360a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/146.a95e6e4f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/147.5f206f67.js"><link rel="prefetch" href="/vuepress-blog/assets/js/148.8576f0c8.js"><link rel="prefetch" href="/vuepress-blog/assets/js/149.4dd88630.js"><link rel="prefetch" href="/vuepress-blog/assets/js/15.4c8b9ac2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/150.02b5521f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/151.443024ba.js"><link rel="prefetch" href="/vuepress-blog/assets/js/152.b87549ce.js"><link rel="prefetch" href="/vuepress-blog/assets/js/153.fd49b944.js"><link rel="prefetch" href="/vuepress-blog/assets/js/154.828a9817.js"><link rel="prefetch" href="/vuepress-blog/assets/js/155.c54ade81.js"><link rel="prefetch" href="/vuepress-blog/assets/js/156.e0dca557.js"><link rel="prefetch" href="/vuepress-blog/assets/js/157.53c342ed.js"><link rel="prefetch" href="/vuepress-blog/assets/js/158.9d41d261.js"><link rel="prefetch" href="/vuepress-blog/assets/js/159.7afe99ae.js"><link rel="prefetch" href="/vuepress-blog/assets/js/16.931d922e.js"><link rel="prefetch" href="/vuepress-blog/assets/js/160.396f65bc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/161.1048b4b7.js"><link rel="prefetch" href="/vuepress-blog/assets/js/162.8ebd2208.js"><link rel="prefetch" href="/vuepress-blog/assets/js/163.ffe51612.js"><link rel="prefetch" href="/vuepress-blog/assets/js/164.b176df83.js"><link rel="prefetch" href="/vuepress-blog/assets/js/165.0c369625.js"><link rel="prefetch" href="/vuepress-blog/assets/js/166.7f99bdcd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/167.22541bb1.js"><link rel="prefetch" href="/vuepress-blog/assets/js/168.168a8adc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/169.ea512b33.js"><link rel="prefetch" href="/vuepress-blog/assets/js/17.30b8f6d4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/170.4d974e6b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/171.6ae58a67.js"><link rel="prefetch" href="/vuepress-blog/assets/js/18.ceb1d3dc.js"><link rel="prefetch" href="/vuepress-blog/assets/js/19.2a86489d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/20.765cc5a4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/21.b5703805.js"><link rel="prefetch" href="/vuepress-blog/assets/js/22.323c52ff.js"><link rel="prefetch" href="/vuepress-blog/assets/js/23.593659ee.js"><link rel="prefetch" href="/vuepress-blog/assets/js/24.9b1e5495.js"><link rel="prefetch" href="/vuepress-blog/assets/js/25.3500eb6d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/26.b173baca.js"><link rel="prefetch" href="/vuepress-blog/assets/js/27.a97b8913.js"><link rel="prefetch" href="/vuepress-blog/assets/js/28.874f46e6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/29.b36d271a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/3.277b5484.js"><link rel="prefetch" href="/vuepress-blog/assets/js/30.a4e5f6ce.js"><link rel="prefetch" href="/vuepress-blog/assets/js/31.e595efb3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/32.952ff03b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/33.bff25d75.js"><link rel="prefetch" href="/vuepress-blog/assets/js/34.77ae1fb9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/35.55dfc8ef.js"><link rel="prefetch" href="/vuepress-blog/assets/js/36.b8a2898d.js"><link rel="prefetch" href="/vuepress-blog/assets/js/37.2a43d960.js"><link rel="prefetch" href="/vuepress-blog/assets/js/38.527255ab.js"><link rel="prefetch" href="/vuepress-blog/assets/js/39.3f13a926.js"><link rel="prefetch" href="/vuepress-blog/assets/js/4.14611c33.js"><link rel="prefetch" href="/vuepress-blog/assets/js/40.8363be0c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/41.5d578d26.js"><link rel="prefetch" href="/vuepress-blog/assets/js/42.92657678.js"><link rel="prefetch" href="/vuepress-blog/assets/js/43.ccdef646.js"><link rel="prefetch" href="/vuepress-blog/assets/js/44.a2e41848.js"><link rel="prefetch" href="/vuepress-blog/assets/js/45.6e94ee4c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/46.3eec9cb4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/47.d8fc0ce5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/48.27898111.js"><link rel="prefetch" href="/vuepress-blog/assets/js/49.9c25ea8f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/5.a497b197.js"><link rel="prefetch" href="/vuepress-blog/assets/js/50.b67e8485.js"><link rel="prefetch" href="/vuepress-blog/assets/js/51.cea9160f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/52.443fabf3.js"><link rel="prefetch" href="/vuepress-blog/assets/js/53.4afa38f6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/54.f6948bac.js"><link rel="prefetch" href="/vuepress-blog/assets/js/55.fd8cfc58.js"><link rel="prefetch" href="/vuepress-blog/assets/js/56.fa58653a.js"><link rel="prefetch" href="/vuepress-blog/assets/js/57.3786d183.js"><link rel="prefetch" href="/vuepress-blog/assets/js/58.b5644507.js"><link rel="prefetch" href="/vuepress-blog/assets/js/6.8a3eb4fd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/60.8bd23158.js"><link rel="prefetch" href="/vuepress-blog/assets/js/61.55f5c8c2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/62.cd6dab9f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/63.2cd07662.js"><link rel="prefetch" href="/vuepress-blog/assets/js/64.ac17be87.js"><link rel="prefetch" href="/vuepress-blog/assets/js/65.48e2a8ca.js"><link rel="prefetch" href="/vuepress-blog/assets/js/66.50f9bbf0.js"><link rel="prefetch" href="/vuepress-blog/assets/js/67.98e26a10.js"><link rel="prefetch" href="/vuepress-blog/assets/js/68.9c4ec456.js"><link rel="prefetch" href="/vuepress-blog/assets/js/69.d6c85bc5.js"><link rel="prefetch" href="/vuepress-blog/assets/js/7.c3e04b24.js"><link rel="prefetch" href="/vuepress-blog/assets/js/70.e6d8ed07.js"><link rel="prefetch" href="/vuepress-blog/assets/js/71.55c90d02.js"><link rel="prefetch" href="/vuepress-blog/assets/js/72.a97cac13.js"><link rel="prefetch" href="/vuepress-blog/assets/js/73.2c2feb26.js"><link rel="prefetch" href="/vuepress-blog/assets/js/74.d61912e6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/75.f703562f.js"><link rel="prefetch" href="/vuepress-blog/assets/js/76.06226909.js"><link rel="prefetch" href="/vuepress-blog/assets/js/77.ed2d9a9c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/78.b09c7bf9.js"><link rel="prefetch" href="/vuepress-blog/assets/js/79.d74b02ec.js"><link rel="prefetch" href="/vuepress-blog/assets/js/80.334679eb.js"><link rel="prefetch" href="/vuepress-blog/assets/js/81.4ec19623.js"><link rel="prefetch" href="/vuepress-blog/assets/js/82.a790145c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/83.92883d1c.js"><link rel="prefetch" href="/vuepress-blog/assets/js/84.849e00be.js"><link rel="prefetch" href="/vuepress-blog/assets/js/85.6adbfec4.js"><link rel="prefetch" href="/vuepress-blog/assets/js/86.465592d2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/87.b099715b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/88.a1663546.js"><link rel="prefetch" href="/vuepress-blog/assets/js/89.2c01b976.js"><link rel="prefetch" href="/vuepress-blog/assets/js/90.7739be30.js"><link rel="prefetch" href="/vuepress-blog/assets/js/91.018ec784.js"><link rel="prefetch" href="/vuepress-blog/assets/js/92.52299c71.js"><link rel="prefetch" href="/vuepress-blog/assets/js/93.6952f508.js"><link rel="prefetch" href="/vuepress-blog/assets/js/94.7cd4e6ab.js"><link rel="prefetch" href="/vuepress-blog/assets/js/95.564f761b.js"><link rel="prefetch" href="/vuepress-blog/assets/js/96.e4a663f2.js"><link rel="prefetch" href="/vuepress-blog/assets/js/97.d328e338.js"><link rel="prefetch" href="/vuepress-blog/assets/js/98.de767ddd.js"><link rel="prefetch" href="/vuepress-blog/assets/js/99.da8eb2b6.js"><link rel="prefetch" href="/vuepress-blog/assets/js/vendors~docsearch.146bbb4c.js">
    <link rel="stylesheet" href="/vuepress-blog/assets/css/0.styles.9508d0de.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress-blog/" class="home-link router-link-active"><img src="/vuepress-blog/assets/img/logo.png" alt="Rui" class="logo"> <span class="site-name can-hide">Rui</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-blog/navigation/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  程序员导航
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow down"></span></button> <button type="button" aria-label="进阶" class="mobile-dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/study-notes/" class="nav-link router-link-active">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/preparation-exams/" class="nav-link">
  备考
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow down"></span></button> <button type="button" aria-label="博文" class="mobile-dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/java/" class="nav-link">
  java
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/mybatis/" class="nav-link">
  mybatis
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/drawing-bed/" class="nav-link">
  图床
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/front-end/" class="nav-link">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/python/" class="nav-link">
  python
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/other/" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码Demo" class="dropdown-title"><span class="title">代码Demo</span> <span class="arrow down"></span></button> <button type="button" aria-label="代码Demo" class="mobile-dropdown-title"><span class="title">代码Demo</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/code-demo/back-end-code/" class="nav-link">
  后端Demo
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/code-demo/front-end-code/" class="nav-link">
  前端Demo
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/code-demo/other.html" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="杂记" class="dropdown-title"><span class="title">杂记</span> <span class="arrow down"></span></button> <button type="button" aria-label="杂记" class="mobile-dropdown-title"><span class="title">杂记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/friendly-chain/" class="nav-link">
  友链
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/read/" class="nav-link">
  阅读
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/aboutme/" class="nav-link">
  关于
</a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/other/" class="nav-link">
  其他
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress-blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/vuepress-blog/navigation/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  程序员导航
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><span class="title">进阶</span> <span class="arrow down"></span></button> <button type="button" aria-label="进阶" class="mobile-dropdown-title"><span class="title">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/study-notes/" class="nav-link router-link-active">
  面经
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/preparation-exams/" class="nav-link">
  备考
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="博文" class="dropdown-title"><span class="title">博文</span> <span class="arrow down"></span></button> <button type="button" aria-label="博文" class="mobile-dropdown-title"><span class="title">博文</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/java/" class="nav-link">
  java
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/mybatis/" class="nav-link">
  mybatis
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/drawing-bed/" class="nav-link">
  图床
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/front-end/" class="nav-link">
  前端
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/python/" class="nav-link">
  python
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/blog-article/other/" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码Demo" class="dropdown-title"><span class="title">代码Demo</span> <span class="arrow down"></span></button> <button type="button" aria-label="代码Demo" class="mobile-dropdown-title"><span class="title">代码Demo</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/code-demo/back-end-code/" class="nav-link">
  后端Demo
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/code-demo/front-end-code/" class="nav-link">
  前端Demo
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/code-demo/other.html" class="nav-link">
  其他
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="杂记" class="dropdown-title"><span class="title">杂记</span> <span class="arrow down"></span></button> <button type="button" aria-label="杂记" class="mobile-dropdown-title"><span class="title">杂记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/vuepress-blog/friendly-chain/" class="nav-link">
  友链
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/read/" class="nav-link">
  阅读
</a></li><li class="dropdown-item"><!----> <a href="/vuepress-blog/aboutme/" class="nav-link">
  关于
</a></li></ul></div></div><div class="nav-item"><a href="/vuepress-blog/other/" class="nav-link">
  其他
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/vuepress-blog/study-notes/back-end/" class="sidebar-heading clickable router-link-active open"><span>后端</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/vuepress-blog/study-notes/back-end/java/" class="sidebar-heading clickable router-link-active open"><span>Java</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress-blog/study-notes/back-end/java/2024JavaInterviewQuestions.html" aria-current="page" class="active sidebar-link">2024版Java面试真题</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vuepress-blog/study-notes/back-end/java/collection.html" class="sidebar-link">Java集合</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/fenbushi.html" class="sidebar-link">分布式理论</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/javase.html" class="sidebar-link">JavaSE</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/javathread.html" class="sidebar-link">Java线程</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/jvm.html" class="sidebar-link">JVM</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/mybatis.html" class="sidebar-link">MyBatis</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/mysql.html" class="sidebar-link">MySQL</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/network.html" class="sidebar-link">计算机网络面试题</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/os.html" class="sidebar-link">操作系统</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/redis.html" class="sidebar-link">Redis</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/rocketmq.html" class="sidebar-link">RocketMQ</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/spring.html" class="sidebar-link">Spring</a></li><li><a href="/vuepress-blog/study-notes/back-end/java/weifuwu.html" class="sidebar-link">微服务</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/vuepress-blog/study-notes/back-end/redis/" class="sidebar-heading clickable"><span>Redis</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/vuepress-blog/study-notes/back-end/python/" class="sidebar-link">Python</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress-blog/study-notes/front-end/" class="sidebar-heading clickable"><span>前端</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/vuepress-blog/study-notes/common/" class="sidebar-heading clickable"><span>公共</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#和-equals-有什么区别">== 和 equals 有什么区别？</a></li><li><a href="#string-属于基本数据类型吗">String 属于基本数据类型吗？</a></li><li><a href="#为什么使用-final-修饰-string">为什么使用 final 修饰 String？</a></li><li><a href="#string、stringbuilder-和-stringbuffer-有什么区别">String、StringBuilder 和 StringBuffer 有什么区别？</a></li><li><a href="#为什么重写-equals-时-必须重写-hashcode">为什么重写 equals 时，必须重写 hashCode？</a></li><li><a href="#int-和-integer-有什么区别">int 和 Integer 有什么区别？</a></li><li><a href="#integer-有什么优点">Integer 有什么优点？</a></li><li><a href="#integer-可以使用-进行比较吗-为什么">Integer 可以使用 == 进行比较吗？为什么？</a></li><li><a href="#final、finally-和-finalize-有什么区别">final、finally 和 finalize 有什么区别？</a></li><li><a href="#普通类和抽象类有哪些区别">普通类和抽象类有哪些区别？</a></li><li><a href="#抽象类必须要有抽象方法吗">抽象类必须要有抽象方法吗？</a></li><li><a href="#抽象类能使用-final-修饰吗">抽象类能使用 final 修饰吗？</a></li><li><a href="#抽象类和接口有什么区别">抽象类和接口有什么区别？</a></li><li><a href="#java-中-this-和-super-有什么区别">Java 中 this 和 super 有什么区别？</a></li><li><a href="#为什么返回类型不算方法重载">为什么返回类型不算方法重载？</a></li><li><a href="#方法重写时需要注意什么问题">方法重写时需要注意什么问题？</a></li><li><a href="#深克隆和浅克隆有什么区别">深克隆和浅克隆有什么区别？</a></li><li><a href="#如何实现深克隆">如何实现深克隆？</a></li><li><a href="#什么是动态代理">什么是动态代理？</a></li><li><a href="#动态代理和静态代理有什么区别">动态代理和静态代理有什么区别？</a></li><li><a href="#如何实现动态代理">如何实现动态代理？</a></li><li><a href="#jdk-proxy-和-cglib-有什么区别">JDK Proxy 和 CGLib 有什么区别？</a></li><li><a href="#动态代理的底层是如何实现的">动态代理的底层是如何实现的？</a></li><li><a href="#说一下反射机制">说一下反射机制？</a></li><li><a href="#如何使用反射">如何使用反射？</a></li><li><a href="#反射有什么优缺点">反射有什么优缺点？</a></li><li><a href="#bio、nio-和-aio-有什么区别">BIO、NIO 和 AIO 有什么区别？</a></li><li><a href="#arraylist-和-linkedlist-有什么区别">ArrayList 和 LinkedList 有什么区别？</a></li><li><a href="#vector-和-arraylist-有什么区别">Vector 和 ArrayList 有什么区别？</a></li><li><a href="#array-和-arraylist-一样吗">Array 和 ArrayList 一样吗？</a></li><li><a href="#如何实现数组和-list-转换">如何实现数组和 List 转换？</a></li><li><a href="#collection-和-collections-有什么区别">Collection 和 Collections 有什么区别？</a></li><li><a href="#comparable-和-comparator-有什么区别">Comparable 和 Comparator 有什么区别？</a></li><li><a href="#hashset-如何保证数据不可重复">HashSet 如何保证数据不可重复？</a></li><li><a href="#hashmap-和-hashtable-有什么区别">HashMap 和 Hashtable 有什么区别？</a></li><li><a href="#hashmap-底层是如何实现的">HashMap 底层是如何实现的？</a></li><li><a href="#说一下-hashmap-新增流程">说一下 HashMap 新增流程？</a></li><li><a href="#为什么链表要升级为红黑树">为什么链表要升级为红黑树？</a></li><li><a href="#什么情况红黑树会退化为链表">什么情况红黑树会退化为链表？</a></li><li><a href="#为什么-hashmap-要使用红黑树">为什么 HashMap 要使用红黑树？</a></li><li><a href="#hashmap-重要的参数有哪些">HashMap 重要的参数有哪些？</a></li><li><a href="#为什么加载因子是-0-75">为什么加载因子是 0.75？</a></li><li><a href="#hashmap-如何解决哈希冲突">HashMap 如何解决哈希冲突？</a></li><li><a href="#concurrenthashmap-如何保证线程安全">ConcurrentHashMap 如何保证线程安全？</a></li><li><a href="#进程和线程有什么区别">进程和线程有什么区别？</a></li><li><a href="#多线程有什么优缺点">多线程有什么优缺点？</a></li><li><a href="#线程的创建方式有哪些">线程的创建方式有哪些？</a></li><li><a href="#如何简单的使用线程">如何简单的使用线程？</a></li><li><a href="#用户线程和守护线程有什么区别">用户线程和守护线程有什么区别？</a></li><li><a href="#线程常用的方法有哪些">线程常用的方法有哪些？</a></li><li><a href="#start-和-run-方法有什么区别">start 和 run 方法有什么区别？</a></li><li><a href="#wait-方法和-sleep-方法有什么区别">wait 方法和 sleep 方法有什么区别？</a></li><li><a href="#说一下线程的生命周期">说一下线程的生命周期？</a></li><li><a href="#怎么终止线程">怎么终止线程？</a></li><li><a href="#线程和线程池有什么区别">线程和线程池有什么区别？</a></li><li><a href="#如何创建线程池">如何创建线程池？</a></li><li><a href="#推荐使用哪种方式来创建线程池">推荐使用哪种方式来创建线程池？</a></li><li><a href="#说一下-threadpoolexecutor-的参数含义">说一下 ThreadPoolExecutor 的参数含义？</a></li><li><a href="#说一下线程池的执行流程">说一下线程池的执行流程？</a></li><li><a href="#线程池的拒绝策略都有哪些">线程池的拒绝策略都有哪些</a></li><li><a href="#如何实现自定义拒绝策略">如何实现自定义拒绝策略？</a></li><li><a href="#线程池中-shutdownnow-和-shutdown-有什么区别">线程池中 shutdownNow() 和 shutdown() 有什么区别？</a></li><li><a href="#多线程存在什么问题">多线程存在什么问题？</a></li><li><a href="#为什么会有线程安全问题">为什么会有线程安全问题？</a></li><li><a href="#如何解决线程安全问题">如何解决线程安全问题？</a></li><li><a href="#synchronized-有几种用法">synchronized 有几种用法？</a></li><li><a href="#synchronized-修饰静态方法和普通方法有什么区别吗">synchronized 修饰静态方法和普通方法有什么区别吗？</a></li><li><a href="#jvm-和-jdk、jre-有什么区别">JVM 和 JDK、JRE 有什么区别？</a></li><li><a href="#jvm-是如何工作的">JVM 是如何工作的？</a></li><li><a href="#说一下类加载机制">说一下类加载机制？</a></li><li><a href="#什么是双亲委派模型">什么是双亲委派模型？</a></li><li><a href="#说一下-jvm-的内存布局">说一下 JVM 的内存布局？</a></li><li><a href="#程序计数器有什么特点">程序计数器有什么特点？</a></li><li><a href="#java-虚拟机栈的作用是什么">Java 虚拟机栈的作用是什么？</a></li><li><a href="#什么情况下会出现栈溢出">什么情况下会出现栈溢出？</a></li><li><a href="#堆和栈有什么区别">堆和栈有什么区别？</a></li><li><a href="#堆有什么特点">堆有什么特点？</a></li><li><a href="#内存溢出和内存泄漏有什么区别">内存溢出和内存泄漏有什么区别？</a></li><li><a href="#方法区中存储了什么内容">方法区中存储了什么内容？</a></li><li><a href="#方法区和永久代是一个东西吗">方法区和永久代是一个东西吗？</a></li><li><a href="#jdk-1-8-元空间有什么变化">JDK 1.8 元空间有什么变化？</a></li><li><a href="#为什么要使用元空间替代永久代">为什么要使用元空间替代永久代？</a></li><li><a href="#如何判断对象的是否需要被回收">如何判断对象的是否需要被回收？</a></li><li><a href="#说一下常用的垃圾回收算法">说一下常用的垃圾回收算法？</a></li><li><a href="#标记-清除算法、标记-整理和复制算法有什么特点">标记-清除算法、标记-整理和复制算法有什么特点？</a></li><li><a href="#mysql-是如何运行的">MySQL 是如何运行的？</a></li><li><a href="#关系型和非关系型数据库的区别">关系型和非关系型数据库的区别？</a></li><li><a href="#说一下数据库的三范式">说一下数据库的三范式？</a></li><li><a href="#mysql-常用引擎有哪些">MySQL 常用引擎有哪些？</a></li><li><a href="#innodb-和-myisam-有什么区别">InnoDB 和 MyISAM 有什么区别？</a></li><li><a href="#mysql-有哪些索引类型">MySQL 有哪些索引类型？</a></li><li><a href="#聚簇索引和非聚簇索引有什么区别">聚簇索引和非聚簇索引有什么区别？</a></li><li><a href="#聚簇索引等于主键索引吗">聚簇索引等于主键索引吗？</a></li><li><a href="#唯一索引和普通索引哪个性能更好">唯一索引和普通索引哪个性能更好？</a></li><li><a href="#临时表是内存表吗">临时表是内存表吗？</a></li><li><a href="#说一下事务的特性">说一下事务的特性？</a></li><li><a href="#事务有哪些隔离级别">事务有哪些隔离级别？</a></li><li><a href="#什么是脏读">什么是脏读？</a></li><li><a href="#什么是不可重复读">什么是不可重复读？</a></li><li><a href="#什么是幻读">什么是幻读？</a></li><li><a href="#不可重复读和幻读有什么区别">不可重复读和幻读有什么区别？</a></li><li><a href="#mysql-事务实现原理是什么">MySQL 事务实现原理是什么？</a></li><li><a href="#mysql-如何保证数据不丢失">MySQL 如何保证数据不丢失？</a></li><li><a href="#redo-log-和-binlog-区别">redo log 和 binlog 区别？</a></li><li><a href="#为什么需要-redo-log">为什么需要 redo log？</a></li><li><a href="#binlog-可以替代-redo-log-吗">binlog 可以替代 redo log 吗？</a></li><li><a href="#mysql-中有哪些锁">MySQL 中有哪些锁？</a></li><li><a href="#mysql-会导致死锁吗">MySQL 会导致死锁吗？</a></li><li><a href="#如何解决-mysql-死锁">如何解决 MySQL 死锁？</a></li><li><a href="#如何查看死锁">如何查看死锁？</a></li><li><a href="#如何避免死锁">如何避免死锁？</a></li><li><a href="#innodb-默认是如何处理死锁的">InnoDB 默认是如何处理死锁的？</a></li><li><a href="#如何实现表锁">如何实现表锁？</a></li><li><a href="#innodb-如何实现行锁">InnoDB 如何实现行锁？</a></li><li><a href="#什么是慢查询">什么是慢查询？</a></li><li><a href="#mysql-优化手段有哪些">MySQL 优化手段有哪些？</a></li><li><a href="#mysql-常见读写分离方案有哪些">MySQL 常见读写分离方案有哪些？</a></li><li><a href="#表的优化策略有哪些">表的优化策略有哪些？</a></li><li><a href="#数据被误删了怎么恢复">数据被误删了怎么恢复？</a></li><li><a href="#drop、truncate-和-delete-有什么区别">drop、truncate 和 delete 有什么区别？</a></li><li><a href="#如何防止数据被误删">如何防止数据被误删？</a></li><li><a href="#mybatis-有什么优缺点">MyBatis 有什么优缺点？</a></li><li><a href="#说说-mybatis-执行流程">说说 MyBatis 执行流程？</a></li><li><a href="#mybatis-和-hibernate-有什么不同">MyBatis 和 Hibernate 有什么不同？</a></li><li><a href="#和-有什么区别">${} 和 #{} 有什么区别？</a></li><li><a href="#什么是-sql-注入">什么是 SQL 注入？</a></li><li><a href="#如何解决实体类属性和表中字段不一致的问题">如何解决实体类属性和表中字段不一致的问题？</a></li><li><a href="#mybatis-中如何实现分页">MyBatis 中如何实现分页？</a></li><li><a href="#rowbounds-是一次性查询全部结果吗">RowBounds 是一次性查询全部结果吗？</a></li><li><a href="#hashmap-和-hashtable-可以作为查询结果吗">HashMap 和 Hashtable 可以作为查询结果吗？</a></li><li><a href="#说一说动态-sql">说一说动态 SQL？</a></li><li><a href="#说一说-mybatis-工作原理">说一说 MyBatis 工作原理？</a></li><li><a href="#说一下-mybatis-延迟加载机制">说一下 MyBatis 延迟加载机制？</a></li><li><a href="#如何设置-mybatis-延迟加载">如何设置 MyBatis 延迟加载？</a></li><li><a href="#说一下-mybatis-的缓存机制">说一下 MyBatis 的缓存机制？</a></li><li><a href="#mybatis-中有哪些设计模式">MyBatis 中有哪些设计模式？</a></li><li><a href="#介绍一下-spring">介绍一下 Spring</a></li><li><a href="#spring-有什么优点">Spring 有什么优点</a></li><li><a href="#什么是-ioc">什么是 IoC？</a></li><li><a href="#ioc-有什么优点">IoC 有什么优点？</a></li><li><a href="#ioc-是如何实现解耦的">IoC 是如何实现解耦的？</a></li><li><a href="#什么是-di">什么是 DI？</a></li><li><a href="#ioc-和-di-有什么区别">IoC 和 DI 有什么区别？</a></li><li><a href="#除了-ioc-和-di-spring-还有什么重要的功能">除了 IoC 和 DI，Spring 还有什么重要的功能？</a></li><li><a href="#说一下-aop">说一下 AOP？</a></li><li><a href="#aop-有什么优点-常见使用场景有哪些">AOP 有什么优点？常见使用场景有哪些？</a></li><li><a href="#aop-是如何组成的">AOP 是如何组成的？</a></li><li><a href="#spring-aop-有几种通知-advice">Spring AOP 有几种通知（Advice）？</a></li><li><a href="#如何实现-spring-aop">如何实现 Spring AOP？</a></li><li><a href="#说一下-spring-aop-实现原理">说一下 Spring AOP 实现原理？</a></li><li><a href="#如何将-bean-存储到-spring">如何将 Bean 存储到 Spring？</a></li><li><a href="#说一下-bean-的命名规则">说一下 Bean 的命名规则？</a></li><li><a href="#bean-名称冲突该如何处理">@Bean 名称冲突该如何处理？</a></li><li><a href="#获取-spring-容器有几种方法">获取 Spring 容器有几种方法？</a></li><li><a href="#applicationcontext-和-beanfactory-有什么区别">ApplicationContext 和 BeanFactory 有什么区别？</a></li><li><a href="#bean-注入有几种方式">Bean 注入有几种方式？</a></li><li><a href="#属性注入有什么缺点">属性注入有什么缺点？</a></li><li><a href="#setter-注入有什么缺点">Setter 注入有什么缺点？</a></li><li><a href="#推荐使用哪种注入方式">推荐使用哪种注入方式？</a></li><li><a href="#autowired-和-resource-有什么区别">@Autowired 和 @Resource 有什么区别？</a></li><li><a href="#bean-有几种作用域">Bean 有几种作用域？</a></li><li><a href="#如何设置-bean-作用域">如何设置 Bean 作用域？</a></li><li><a href="#说一下-bean-的生命周期">说一下 Bean 的生命周期？</a></li><li><a href="#spring-使用了哪些设计模式">Spring 使用了哪些设计模式？</a></li><li><a href="#spring-mvc-和-spring-有什么区别">Spring MVC 和 Spring 有什么区别？</a></li><li><a href="#mvc-有什么优点">MVC 有什么优点？</a></li><li><a href="#说一下-spring-mvc-执行流程">说一下 Spring MVC 执行流程？</a></li><li><a href="#spring-mvc-重要组件有哪些">Spring MVC 重要组件有哪些？</a></li><li><a href="#如何进行路由注册">如何进行路由注册？</a></li><li><a href="#怎么接收-json-格式参数">怎么接收 JSON 格式参数？</a></li><li><a href="#如何从-url-中获取参数">如何从 URL 中获取参数？</a></li><li><a href="#如何获取并保存前端上传的文件">如何获取并保存前端上传的文件？</a></li><li><a href="#怎么实现请求转发和请求重定向">怎么实现请求转发和请求重定向？</a></li><li><a href="#请求转发和请求重定向有什么区别">请求转发和请求重定向有什么区别？</a></li><li><a href="#spring-mvc-中文乱码问题应该如何处理">Spring MVC 中文乱码问题应该如何处理？</a></li><li><a href="#request-有几种获取方式">request 有几种获取方式？</a></li><li><a href="#spring-mvc-如何处理跨域问题">Spring MVC 如何处理跨域问题？</a></li><li><a href="#为什么会有跨域问题">为什么会有跨域问题？</a></li><li><a href="#spring-和-spring-boot-有什么区别">Spring 和 Spring Boot 有什么区别？</a></li><li><a href="#spring-boot-有什么优点">Spring Boot 有什么优点？</a></li><li><a href="#说一下-spring-boot-启动流程">说一下 Spring Boot 启动流程？</a></li><li><a href="#ant、maven-和-gradle-有什么区别">Ant、Maven 和 Gradle 有什么区别？</a></li><li><a href="#properties-和-yml-有什么区别">properties 和 yml 有什么区别？</a></li><li><a href="#springboot-如何读取配置文件">SpringBoot 如何读取配置文件？</a></li><li><a href="#配置文件中中文乱码问题如何处理">配置文件中中文乱码问题如何处理？</a></li><li><a href="#如何实现拦截器">如何实现拦截器？</a></li><li><a href="#如何实现过滤器">如何实现过滤器？</a></li><li><a href="#拦截器和过滤器有什么区别">拦截器和过滤器有什么区别？</a></li><li><a href="#如何操作事务">如何操作事务？</a></li><li><a href="#导致-transactional-失效的场景有哪些">导致 @Transactional 失效的场景有哪些？</a></li><li><a href="#为什么非-public-方法-transactional-会失效">为什么非 public 方法 @Transactional 会失效？</a></li><li><a href="#为什么-try-catch-之后-事务不能自动回滚了">为什么 try-catch 之后，事务不能自动回滚了？</a></li><li><a href="#如何处理事务不自动回滚的问题">如何处理事务不自动回滚的问题？</a></li><li><a href="#为什么调用类内部-transactional-事务会失效">为什么调用类内部 @Transactional 事务会失效？</a></li><li><a href="#说一下-transactional-工作原理">说一下 @Transactional 工作原理？</a></li><li><a href="#spring-有几种事务隔离级别">Spring 有几种事务隔离级别？</a></li><li><a href="#说一下-spring-事务传播机制">说一下 Spring 事务传播机制？</a></li><li><a href="#加入事务和嵌套事务有什么区别">加入事务和嵌套事务有什么区别？</a></li><li><a href="#事务隔离级别和传播机制有什么区别">事务隔离级别和传播机制有什么区别？</a></li><li><a href="#如何进行统一异常处理">如何进行统一异常处理？</a></li><li><a href="#java-有几种架构类型">Java 有几种架构类型？</a></li><li><a href="#restful-和-rpc-有什么区别">RESTful 和 RPC 有什么区别？</a></li><li><a href="#微服务中的-服务-怎么理解">微服务中的“服务”怎么理解？</a></li><li><a href="#微服务有什么优点">微服务有什么优点？</a></li><li><a href="#微服务有什么缺点">微服务有什么缺点？</a></li><li><a href="#微服务中有哪些组件">微服务中有哪些组件？</a></li><li><a href="#微服务和-spring-cloud-有什么关系">微服务和 Spring Cloud 有什么关系？</a></li><li><a href="#什么是-spring-cloud">什么是 Spring Cloud？</a></li><li><a href="#spring-boot-和-spring-cloud-有什么区别">Spring Boot 和 Spring Cloud 有什么区别？</a></li><li><a href="#spring-cloud-和-dubbo-有什么区别">Spring Cloud 和 Dubbo 有什么区别？</a></li><li><a href="#什么是-spring-cloud-netflix">什么是 Spring Cloud Netflix？</a></li><li><a href="#eureka-和-zookeeper-有什么区别">Eureka 和 ZooKeeper 有什么区别？</a></li><li><a href="#什么是-eureka-的自我保护机制">什么是 Eureka 的自我保护机制?</a></li><li><a href="#spring-cloud-alibaba-提供了什么功能">Spring Cloud Alibaba 提供了什么功能？</a></li><li><a href="#spring-cloud-alibaba-有哪些组件">Spring Cloud Alibaba 有哪些组件？</a></li><li><a href="#什么是服务注册和服务发现">什么是服务注册和服务发现？</a></li><li><a href="#服务发现有几种模式">服务发现有几种模式？</a></li><li><a href="#这两种服务发现模式有什么区别">这两种服务发现模式有什么区别？</a></li><li><a href="#问题-服务注册有几种方式">问题：服务注册有几种方式？</a></li><li><a href="#什么是负载均衡">什么是负载均衡？</a></li><li><a href="#负载均衡有几种类型">负载均衡有几种类型？</a></li><li><a href="#服务端负载均衡和客户端负载均衡有什么区别">服务端负载均衡和客户端负载均衡有什么区别？</a></li><li><a href="#ribbon-有哪些负载均衡策略">Ribbon 有哪些负载均衡策略？</a></li><li><a href="#说一下什么是限流">说一下什么是限流？</a></li><li><a href="#限流的处理方式有哪些">限流的处理方式有哪些？</a></li><li><a href="#限流实现算法有哪些">限流实现算法有哪些？</a></li><li><a href="#什么是-sentinel">什么是 Sentinel？</a></li><li><a href="#sentinel-提供了哪些功能">Sentinel 提供了哪些功能？</a></li><li><a href="#sentinel-有什么优点">Sentinel 有什么优点？</a></li><li><a href="#sentinel-有哪些核心组件">Sentinel 有哪些核心组件？</a></li><li><a href="#sentinel-是如何运作的">Sentinel 是如何运作的？</a></li><li><a href="#什么是-nacos">什么是 Nacos？</a></li><li><a href="#nacos-提供了哪些功能">Nacos 提供了哪些功能？</a></li><li><a href="#nacos-生态如何">Nacos 生态如何？</a></li><li><a href="#nacos-组成部分有哪些">Nacos 组成部分有哪些？</a></li><li><a href="#nacos-部署方式有几种">Nacos 部署方式有几种？</a></li><li><a href="#如何启动-nacos-服务器">如何启动 Nacos 服务器？</a></li><li><a href="#nacos-单机和集群部署有什么区别吗">Nacos 单机和集群部署有什么区别吗？</a></li><li><a href="#nacos-配置中心有什么优点">Nacos 配置中心有什么优点？</a></li><li><a href="#如何实现-nacos-配置项的动态刷新">如何实现 Nacos 配置项的动态刷新？</a></li><li><a href="#当客户端连接不到-nacos-配置服务时会怎么">当客户端连接不到 Nacos 配置服务时会怎么？</a></li><li><a href="#什么是注册中心">什么是注册中心？</a></li><li><a href="#nacos-有几种服务类型">Nacos 有几种服务类型？</a></li><li><a href="#说一下-nacos-中的健康检测机制">说一下 Nacos 中的健康检测机制？</a></li><li><a href="#什么是保护阈值">什么是保护阈值？</a></li><li><a href="#nacos-有负载均衡吗">Nacos 有负载均衡吗？</a></li><li><a href="#nacos-是-ap-模式还是-cp-模式">Nacos 是 AP 模式还是 CP 模式？</a></li></ul></div><p></p> <h1 id="_2024版java面试真题"><a href="#_2024版java面试真题" class="header-anchor">#</a> 2024版Java面试真题</h1> <h3 id="和-equals-有什么区别"><a href="#和-equals-有什么区别" class="header-anchor">#</a> == 和 equals 有什么区别？</h3> <p>== 对于基本数据类型来说，是用于比较 “值”是否相等的；而对于引用类型来说，是用于比较引用地址是否相同的；而 equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p> <p>查看源码我们可以知道 Object 中也有 equals()  方法，源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>可以看出，Object 中的 equals() 方法其实就是 ==，而 String 重写了 equals() 方法把它修改成比较两个字符串的值是否相等。</p> <p>源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对象引用相同直接返回 true</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> anObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断需要对比的值是否为 String 类型，如果不是则直接返回 false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> anotherString <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>anObject<span class="token punctuation">;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> value<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 把两个字符串都转换为 char 数组对比</span>
            <span class="token keyword">char</span> v1<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
            <span class="token keyword">char</span> v2<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> anotherString<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token comment">// 循环比对两个字符串的每一个字符</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果其中有一个字符不相等就 true false，否则继续对比</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>v1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> v2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                i<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><h3 id="string-属于基本数据类型吗"><a href="#string-属于基本数据类型吗" class="header-anchor">#</a> String 属于基本数据类型吗？</h3> <p>String 不属于基础类型，在 Java 中，一共有 8 种基本类型（primitive type），其中有 4 种整型、2 种浮点类型、1 种用于表示 Unicode 编码的字符类型 char 和 1 种用于表示真假值的 boolean 类型。</p> <ol><li>4 种整型：int、short、long、byte</li> <li>2 种浮点类型：float、double</li> <li>字符类型：char</li> <li>真假类型：boolean</li></ol> <p>基本数据类型是指不可再分的原子数据类型，内存中直接存储此类型的值，通过内存地址即可直接访问到数据，并且此内存区域只能存放这种类型的值。</p> <p>基本数据类型不能应用于泛型，而 String 却可以。</p> <h3 id="为什么使用-final-修饰-string"><a href="#为什么使用-final-修饰-string" class="header-anchor">#</a> 为什么使用 final 修饰 String？</h3> <p>使用 final 修饰 String 的第一个好处是安全，第二个好处是高效。</p> <p>Java 语言之父 James Gosling 的回答，他会更倾向于使用 final，因为它能够缓存结果，当你在传参时不需要考虑谁会修改它的值；如果是可变类的话，则有可能需要重新拷贝出来一个新值进行传参，这样在性能上就会有一定的损失。</p> <p>James Gosling 还说，迫使 String 类设计成不可变的另一个原因是安全，当你在调用其他方法时，比如调用一些系统级操作指令之前，可能会有一系列校验，如果是可变类的话，可能在你校验过后，它的内部的值又被改变了，这样有可能会引起严重的系统崩溃问题，这是迫使 String 类设计成不可变类的一个重要原因。</p> <h3 id="string、stringbuilder-和-stringbuffer-有什么区别"><a href="#string、stringbuilder-和-stringbuffer-有什么区别" class="header-anchor">#</a> String、StringBuilder 和 StringBuffer 有什么区别？</h3> <p>因为 String 类型是不可变的，所以在字符串拼接的时候如果使用 String 的话性能会很低，因此我们就需要使用另一个数据类型 StringBuffer，它提供了 append 和 insert 方法可用于字符串的拼接，它使用 synchronized 来保证线程安全，如下源码所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">StringBuffer</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    toStringCache <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">StringBuffer</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">String</span> str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    toStringCache <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>因为它使用了 synchronized 来保证线程安全，所以性能不是很高，于是在 JDK 1.5 就有了 StringBuilder，它同样提供了 append 和 insert 的拼接方法，但它没有使用 synchronized 来修饰，因此在性能上要优于 StringBuffer，所以在非并发操作的环境下可使用 StringBuilder 来进行字符串拼接。</p> <p>小结：String 是不可变的，所以在进行字符拼接时效率很低，而 StringBuffer 可以替代 String 来进行字符串拼接，并且能保证线程安全，但因为使用 synchronized 所以效率不高，而 StringBuilder 可以更高效的拼接字符串，但不能保证线程安全。</p> <h3 id="为什么重写-equals-时-必须重写-hashcode"><a href="#为什么重写-equals-时-必须重写-hashcode" class="header-anchor">#</a> 为什么重写 equals 时，必须重写 hashCode？</h3> <p>equals 和 hashCode  两个方法是用来协同判断两个对象是否相等的，采用这种方式的原因是可以提高程序插入和查询的速度，如果在重写 equals 时，不重写 hashCode，就会导致在某些场景下，例如将两个相等的自定义对象存储在 Set 集合时，就会出现程序执行的异常，为了保证程序的正常执行，所以我们就需要在重写 equals 时，也一并重写 hashCode 方法才行。</p> <p><strong>异常问题分析</strong></p> <p>比如在 Set 集合存储数据时，如果只重写了 equals 方法，那么默认情况下，Set 进行去重判断时，会先判断两个对象的 hashCode 是否相同，而此时因为没有重写 hashCode 方法，所以会默认调用 Object 中的 hashCode 方法，而 Object 中的 hashCode 方法会得到两个对象的哈希值，而两个对象因为引用地址不同，所以哈希的结果也是不同的，因此会直接返回 false，于是 Set 集合就插入了两个相等的对象。</p> <p>但是，如果在重写 equals 方法时，也重写了 hashCode 方法，那么在执行判断时会去执行重写的 hashCode 方法，此时对比的是两个对象的所有属性的 hashCode，因为属性为基础数据类型或 String，所以哈希之后得到的 hashCode 值也是相同的，于是再去调用 equals 方法，发现两个对象确实是相等的，于是就返回 true 了，因此 Set 集合就不会存储两个相等的数据了，那么整个程序也能正常执行了。</p> <h3 id="int-和-integer-有什么区别"><a href="#int-和-integer-有什么区别" class="header-anchor">#</a> int 和 Integer 有什么区别？</h3> <p>int 和 Integer的区别主要体现在以下几个方面：</p> <ol><li>数据类型不同：int 是基础数据类型，而 Integer 是包装数据类型；</li> <li>默认值不同：int 的默认值是 0，而 Integer 的默认值是 null；</li> <li>内存中存储的方式不同：int 在内存中直接存储的是数据值，而 Integer 实际存储的是对象引用，当 new 一个 Integer 时实际上是生成一个指针指向此对象；</li> <li>实例化方式不同：Integer 必须实例化才可以使用，而 int 不需要；</li> <li>变量的比较方式不同：int 可以使用 == 来对比两个变量是否相等，而 Integer 一定要使用 equals 来比较两个变量是否相等。</li></ol> <h3 id="integer-有什么优点"><a href="#integer-有什么优点" class="header-anchor">#</a> Integer 有什么优点？</h3> <p>包装类 Integer 的优点是解决了基本数据类型无法做到的事情泛型类型参数、序列化、类型转换、高频区间数据缓存等问题。</p> <h3 id="integer-可以使用-进行比较吗-为什么"><a href="#integer-可以使用-进行比较吗-为什么" class="header-anchor">#</a> Integer 可以使用 == 进行比较吗？为什么？</h3> <p>Integer 不能使用 == 比较，因为 Integer 本身是对象，而 == 比较的是对象地址，所以不能使用== 比较。</p> <h3 id="final、finally-和-finalize-有什么区别"><a href="#final、finally-和-finalize-有什么区别" class="header-anchor">#</a> final、finally 和 finalize 有什么区别？</h3> <p>final、finally 和 finalize 从英文字面角度来看，看似很像，实则 3 者在 Java 中没任何关系。final 是用来修饰类、方法、变量和参数的关键字，被 final 修饰的对象不允许修改或替换其原始值或定义；finally 是 Java 中保证重点代码一定要被执行的一种机制；finalize 是 Object 类中的一个基础方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收的，但其执行“不稳定”，且有一定的性能问题，已经在 JDK 9 中被设置为弃用的方法了。</p> <h3 id="普通类和抽象类有哪些区别"><a href="#普通类和抽象类有哪些区别" class="header-anchor">#</a> 普通类和抽象类有哪些区别？</h3> <ol><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li> <li>抽象类不能直接实例化，普通类可以直接实例化。</li></ol> <h3 id="抽象类必须要有抽象方法吗"><a href="#抽象类必须要有抽象方法吗" class="header-anchor">#</a> 抽象类必须要有抽象方法吗？</h3> <p>不需要，抽象类不一定非要有抽象方法。</p> <h3 id="抽象类能使用-final-修饰吗"><a href="#抽象类能使用-final-修饰吗" class="header-anchor">#</a> 抽象类能使用 final 修饰吗？</h3> <p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。</p> <h3 id="抽象类和接口有什么区别"><a href="#抽象类和接口有什么区别" class="header-anchor">#</a> 抽象类和接口有什么区别？</h3> <p>接口和抽象类都是用来定义对象的公共行为的，但二者有以下 7 点不同：</p> <ol><li>定义的关键字不同；</li> <li>子类继承或实现关键字不同；</li> <li>类型扩展不同：抽象类是单继承，而接口是多继承；</li> <li>方法访问控制符：抽象类无限制，只是抽象类中的抽象方法不能被 private 修饰；而接口有限制，接口默认的是 public 控制符；</li> <li>属性方法控制符：抽象类无限制，而接口有限制，接口默认的是 public 控制符；</li> <li>方法实现不同：抽象类中的普通方法必须有实现，抽象方法必须没有实现；而接口中普通方法不能有实现，但在 JDK 8 中的 static 和 defualt 方法必须有实现；</li> <li>静态代码块的使用不同：抽象类可以有静态代码块，而接口不能有。</li></ol> <h3 id="java-中-this-和-super-有什么区别"><a href="#java-中-this-和-super-有什么区别" class="header-anchor">#</a> Java 中 this 和 super 有什么区别？</h3> <p>this 和 super 都是 Java 中的关键字，都起指代作用，当显式使用它们时，都需要将它们放在方法的首行（否则编译器会报错）。this 表示当前对象，super 用来指代父类对象，它们有四点不同：</p> <ol><li>指代对象：super 指代的是父类，是用来访问父类的；而 this 指代的是当前类；</li> <li>查找访问：super 只能查找父类，而 this 会先从本类中找，如果找不到则会去父类中找；</li> <li>本类属性赋值：this 可以用来为本类的实例属性赋值，而 super 则不能实现此功能；</li> <li>配合 synchronized 使用不同：因为 this 表示当前对象，所以this 可用于 synchronized(this){....} 加锁，而 super 则不能实现此功能。</li></ol> <h3 id="为什么返回类型不算方法重载"><a href="#为什么返回类型不算方法重载" class="header-anchor">#</a> 为什么返回类型不算方法重载？</h3> <p>因为不同的返回值类型，JVM 没办法分辨到底要调用哪个方法，JVM 调用方法是通过方法签名来判断到底要调用哪个方法的，而方法签名 = 方法名称 + 参数类型 + 参数个数组成的一个唯一值，这个唯一值就是方法签名。</p> <p>从方法签名的组成可以看出，返回类型不是方法签名的组成部分，所以不同的返回类型也就不算方法重载了，因为它不能让 JVM 确定要调用的具体方法。</p> <h3 id="方法重写时需要注意什么问题"><a href="#方法重写时需要注意什么问题" class="header-anchor">#</a> 方法重写时需要注意什么问题？</h3> <p>Java 中的方法重写（Override）是在子类重新定义父类已有方法的过程，它是面向对象编程中多态的具体表现。我们可以通过 @Override 关键字重写父类中的某个方法，但在重写的过程中需要注意以下 5 个问题：</p> <ol><li>子类方法的权限控制符不能变小；</li> <li>子类方法返回的类型只能变小；</li> <li>子类抛出异常的类型只能变小；</li> <li>子类方法名必须和父类保持一致；</li> <li>子类方法的参数类型和个数必须和父类保持一致。</li></ol> <h3 id="深克隆和浅克隆有什么区别"><a href="#深克隆和浅克隆有什么区别" class="header-anchor">#</a> 深克隆和浅克隆有什么区别？</h3> <p>深克隆（Deep Clone）是将原型对象中的所有类型，无论是值类型还是引用类型，都复制一份给克隆对象，也就是说深克隆会把原型对象和原型对象所引用的对象，都复制一份给克隆对象。</p> <p>浅克隆（Shadow Clone）是把原型对象中成员变量为值类型的属性都复制给克隆对象，把原型对象中成员变量为引用类型的引用地址也复制给克隆对象，也就是原型对象中如果有成员变量为引用对象，则此引用对象的地址是共享给原型对象和克隆对象的。简单来说就是浅克隆只会复制原型对象，但不会复制它所引用的对象。</p> <p>所以深克隆和浅克隆的主要区别在于：深克隆会复制原型对象和它所引用所有对象，而浅克隆只会复制原型对象。</p> <h3 id="如何实现深克隆"><a href="#如何实现深克隆" class="header-anchor">#</a> 如何实现深克隆？</h3> <p>深克隆的实现方式有很多种，大体可以分为以下几类：</p> <ol><li>所有对象都实现克隆方法；</li> <li>通过构造方法实现深克隆；</li> <li>使用 JDK 自带的字节流实现深克隆；</li></ol> <ul><li>所有对象都实现克隆方法</li></ul> <p>这种方式需要让所有的引用对象都实现克隆（Cloneable 接口），示例代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CloneExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建被赋值对象</span>
        <span class="token class-name">Address</span> address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token number">001</span><span class="token punctuation">,</span> <span class="token string">&quot;北京&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">People</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;Java&quot;</span><span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 克隆 p1 对象</span>
        <span class="token class-name">People</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 修改原型对象</span>
        p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCity</span><span class="token punctuation">(</span><span class="token string">&quot;上海&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出 p1 和 p2 地址信息</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p1:&quot;</span> <span class="token operator">+</span> p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                <span class="token string">&quot; p2:&quot;</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Address</span> address<span class="token punctuation">;</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">People</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
            <span class="token class-name">People</span> people <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">People</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            people<span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>address<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 引用类型克隆赋值</span>
            <span class="token keyword">return</span> people<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Address</span> <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token class-name">Address</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Address</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">protected</span> <span class="token class-name">Address</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Address</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCity</span><span class="token punctuation">(</span><span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br></div></div><p>这样 People 类就实现深克隆了。</p> <ul><li>通过构造方法实现深克隆</li></ul> <p>《Effective Java》 中推荐使用构造器（Copy Constructor）来实现深克隆，如果构造器的参数为基本数据类型或字符串类型则直接赋值，如果是对象类型，则需要重新 new 一个对象，实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecondExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建对象</span>
        <span class="token class-name">Address</span> address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token number">001</span><span class="token punctuation">,</span> <span class="token string">&quot;北京&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">People</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;Java&quot;</span><span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用构造函数克隆对象</span>
        <span class="token class-name">People</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 修改原型对象</span>
        p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCity</span><span class="token punctuation">(</span><span class="token string">&quot;上海&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出 p1 和 p2 地址信息</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p1:&quot;</span> <span class="token operator">+</span> p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                <span class="token string">&quot; p2:&quot;</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Address</span> address<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Address</span> <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token class-name">Address</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Address</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCity</span><span class="token punctuation">(</span><span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br></div></div><ul><li>使用 JDK 自带的字节流实现深克隆</li></ul> <p>通过 JDK 自带的字节流实现深克隆的方式，是先将要原型对象写入到内存中的字节流，然后再从这个字节流中读出刚刚存储的信息，来作为一个新的对象返回，那么这个新对象和原型对象就不存在任何地址上的共享，这样就实现了深克隆，代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThirdExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建对象</span>
        <span class="token class-name">Address</span> address <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token number">001</span><span class="token punctuation">,</span> <span class="token string">&quot;北京&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">People</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&quot;Java&quot;</span><span class="token punctuation">,</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 通过字节流实现克隆</span>
        <span class="token class-name">People</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">People</span><span class="token punctuation">)</span> <span class="token class-name">StreamClone</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 修改原型对象</span>
        p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCity</span><span class="token punctuation">(</span><span class="token string">&quot;上海&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出 p1 和 p2 地址信息</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;p1:&quot;</span> <span class="token operator">+</span> p1<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                <span class="token string">&quot; p2:&quot;</span> <span class="token operator">+</span> p2<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">StreamClone</span> <span class="token punctuation">{</span>

        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">Serializable</span>### <span class="token class-name">T</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token class-name">People</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">T</span> cloneObj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token comment">// 写入字节流</span>
                <span class="token class-name">ByteArrayOutputStream</span> bo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">ObjectOutputStream</span> oos <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectOutputStream</span><span class="token punctuation">(</span>bo<span class="token punctuation">)</span><span class="token punctuation">;</span>
                oos<span class="token punctuation">.</span><span class="token function">writeObject</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
                oos<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 分配内存,写入原始对象,生成新对象</span>
                <span class="token class-name">ByteArrayInputStream</span> bi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayInputStream</span><span class="token punctuation">(</span>bo<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//获取上面的输出字节流</span>
                <span class="token class-name">ObjectInputStream</span> oi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectInputStream</span><span class="token punctuation">(</span>bi<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 返回生成的新对象</span>
                cloneObj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">)</span> oi<span class="token punctuation">.</span><span class="token function">readObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                oi<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> cloneObj<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">People</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">Address</span> address<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Address</span> <span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token class-name">Address</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Address</span> address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>


    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Address</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> city<span class="token punctuation">;</span>

        <span class="token keyword">public</span> <span class="token class-name">Integer</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getCity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCity</span><span class="token punctuation">(</span><span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">public</span> <span class="token class-name">Address</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">,</span> <span class="token class-name">String</span> city<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>city <span class="token operator">=</span> city<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br></div></div><p>此方式需要注意的是，由于是通过字节流序列化实现的深克隆，因此每个对象必须能被序列化，必须实现 Serializable 接口，标识自己可以被序列化，否则会抛出异常 (java.io.NotSerializableException)。</p> <h3 id="什么是动态代理"><a href="#什么是动态代理" class="header-anchor">#</a> 什么是动态代理？</h3> <p>动态代理是在程序运行期，动态的创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。</p> <p>在生成代理对象的过程中，目标对象不变，代理对象中的方法是目标对象方法的增强方法。可以理解为运行期间，对象中方法的动态拦截，在拦截方法的前后执行功能操作。</p> <p>动态代理的常见使用场景有：</p> <ol><li>统计每个 api 的请求耗时；</li> <li>统一的日志输出；</li> <li>校验被调用的 api 是否已经登录和权限鉴定；</li> <li>Spring AOP。</li></ol> <h3 id="动态代理和静态代理有什么区别"><a href="#动态代理和静态代理有什么区别" class="header-anchor">#</a> 动态代理和静态代理有什么区别？</h3> <p>静态代理其实就是事先写好代理类，可以手工编写也可以使用工具生成，但它的缺点是每个业务类都要对应一个代理类，特别不灵活也不方便。</p> <p>动态代理是在程序运行期，动态的创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术。</p> <p>所以总结来说，动态代理和静态代理的效果都是一样的，但静态代理使用麻烦，而动态代理使用简单，后者也是现在编程中实现代理的主流方式。</p> <h3 id="如何实现动态代理"><a href="#如何实现动态代理" class="header-anchor">#</a> 如何实现动态代理？</h3> <p>在 Java 中，实现动态代理的常用方式是 JDK Proxy 和 CGLib。</p> <h3 id="jdk-proxy-和-cglib-有什么区别"><a href="#jdk-proxy-和-cglib-有什么区别" class="header-anchor">#</a> JDK Proxy 和 CGLib 有什么区别？</h3> <p>JDK Proxy 和 CGLib 的区别主要体现在以下几个方面：</p> <ol><li>JDK Proxy 是 Java 语言自带的功能，无需通过加载第三方类实现；</li> <li>Java 对 JDK Proxy 提供了稳定的支持，并且会持续的升级和更新 JDK Proxy，例如 Java 8 版本中的 JDK Proxy 性能相比于之前版本提升了很多；</li> <li>JDK Proxy 是通过拦截器加反射的方式实现的；</li> <li>JDK Proxy 只能代理继承接口的类；</li> <li>JDK Proxy 实现和调用起来比较简单；</li> <li>CGLib 是第三方提供的工具，基于 ASM 实现的，性能比较高；</li> <li>CGLib 无需通过接口来实现，它是通过实现子类的方式来完成调用的。</li></ol> <h3 id="动态代理的底层是如何实现的"><a href="#动态代理的底层是如何实现的" class="header-anchor">#</a> 动态代理的底层是如何实现的？</h3> <p>不同的动态代理的底层实现是不同的，比如 JDK Proxy 底层是通过反射技术实现的，而 CGLib 是基于 ASM，一个 Java 字节码操作框架实现的。</p> <h3 id="说一下反射机制"><a href="#说一下反射机制" class="header-anchor">#</a> 说一下反射机制？</h3> <p>Java 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为 Java 语言的反射机制。简单来说，反射机制指的是程序在运行时能够获取自身的信息。在 Java 中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p> <p>Java 反射机制主要提供了以下功能，这些功能都位于 java.lang.reflect 包：</p> <ol><li>在运行时判断任意一个对象所属的类；</li> <li>在运行时构造任意一个类的对象；</li> <li>在运行时判断任意一个类所具有的成员变量和方法；</li> <li>在运行时调用任意一个对象的方法；</li> <li>生成动态代理。</li></ol> <p>在程序开发中反射的使用场景有很多，比如以下几个。</p> <p><strong>使用场景一</strong>：编程工具 IDEA 或 Eclipse 等，在写代码时会有代码（属性或方法名）提示，就是因为使用了反射；</p> <p><strong>使用场景二</strong>：很多知名的框架，如 Spring、MyBatis 等，为了让程序更优雅更简洁，也会使用到反射。</p> <p>例如，Spring 可以通过配置来加载不同的类，调用不同的方法，代码如下所示：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;bean id=&quot;person&quot; class=&quot;com.spring.beans.Person&quot; init-method=&quot;initPerson&quot;###
&lt;/bean###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>例如，MyBatis 在 Mapper 使用外部类的 Sql 构建查询时，代码如下所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@SelectProvider</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">PersonSql</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token string">&quot;getListSql&quot;</span><span class="token punctuation">)</span>
<span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">Person</span>### <span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">PersonSql</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getListSql</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> sql <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SQL</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span>
            <span class="token function">SELECT</span><span class="token punctuation">(</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">FROM</span><span class="token punctuation">(</span><span class="token string">&quot;person&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> sql<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>使用场景三</strong>：数据库连接池，也会使用反射调用不同类型的数据库驱动，代码如下所示：</p> <div class="language-properties line-numbers-mode"><pre class="language-properties"><code><span class="token key attr-name">String</span> <span class="token value attr-value">url = &quot;jdbc:mysql://127.0.0.1:3306/mydb&quot;;</span>
<span class="token key attr-name">String</span> <span class="token value attr-value">username = &quot;root&quot;;</span>
<span class="token key attr-name">String</span> <span class="token value attr-value">password = &quot;root&quot;;</span>
Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
<span class="token key attr-name">Connection</span> <span class="token value attr-value">connection = DriverManager.getConnection(url, username, password);</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="如何使用反射"><a href="#如何使用反射" class="header-anchor">#</a> 如何使用反射？</h3> <p>在 Java 中，反射获取调用类可以通过 Class.forName()，反射获取类实例要通过 newInstance()，相当于 new 一个新对象，反射获取方法要通过 getMethod()，获取到类方法之后使用 invoke() 对类方法进行调用。如果是类方法为私有方法的话，则需要通过 setAccessible(true) 来修改方法的访问限制，以上的这些操作就是反射的基本使用，具体调用如下。</p> <ul><li>反射调用静态方法</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span> myClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;类名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Method</span> method <span class="token operator">=</span> myClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;调用方法名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>myClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>反射调用公共方法</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span> myClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;类名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建实例对象（相当于 new ）</span>
<span class="token class-name">Object</span> instance <span class="token operator">=</span> myClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Method</span> method2 <span class="token operator">=</span> myClass<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;调用方法名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
method2<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>反射调用私有方法</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Class</span> myClass <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">&quot;类名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建实例对象（相当于 new ）</span>
<span class="token class-name">Object</span> object <span class="token operator">=</span> myClass<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Method</span> method3 <span class="token operator">=</span> myClass<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">&quot;调用方法名&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
method3<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
method3<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="反射有什么优缺点"><a href="#反射有什么优缺点" class="header-anchor">#</a> 反射有什么优缺点？</h3> <p>优点：</p> <ol><li>能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性；</li> <li>与 Java 动态编译相结合，可以实现无比强大的功能；</li> <li>对于 Java 这种先编译再运行的语言，能够让我们很方便的创建灵活的代码，这些代码可以在运行时装配，无需在组件之间进行源代码的链接，更加容易实现面向对象。</li></ol> <p>缺点：</p> <ol><li>反射会消耗一定的系统资源，因此，如果不需要动态地创建一个对象，那么就不需要用反射；</li> <li>反射调用方法时可以忽略权限检查，获取这个类的私有方法和属性，因此可能会破坏类的封装性而导致安全问题。</li></ol> <h3 id="bio、nio-和-aio-有什么区别"><a href="#bio、nio-和-aio-有什么区别" class="header-anchor">#</a> BIO、NIO 和 AIO 有什么区别？</h3> <p>它们三者都是用来实现 IO（Input/Output）操作的，它们的区别如下。</p> <ol><li>BIO 传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。它的优点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。</li> <li>NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式。</li> <li>AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，因此人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ol> <p>简单来说：BIO 就是传统 IO 包，产生的最早；NIO 是对 BIO 的改进提供了多路复用的同步非阻塞 IO，而 AIO 是 NIO 的升级，提供了异步非阻塞 IO。</p> <h3 id="arraylist-和-linkedlist-有什么区别"><a href="#arraylist-和-linkedlist-有什么区别" class="header-anchor">#</a> ArrayList 和 LinkedList 有什么区别？</h3> <p>它们的区别有以下几个：</p> <ol><li>数据结构实现不同：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li> <li>随机访问效率不同：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li> <li>增加和删除效率不同：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</li></ol> <p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p> <h3 id="vector-和-arraylist-有什么区别"><a href="#vector-和-arraylist-有什么区别" class="header-anchor">#</a> Vector 和 ArrayList 有什么区别？</h3> <p>它们的区别有以下几个：</p> <ol><li>线程安全方面：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的；</li> <li>性能方面：ArrayList 在性能方面要优于 Vector；</li> <li>扩容方面：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ol> <h3 id="array-和-arraylist-一样吗"><a href="#array-和-arraylist-一样吗" class="header-anchor">#</a> Array 和 ArrayList 一样吗？</h3> <p>二者是不同的，Array 是数组，ArrayList 是集合，它们的区别有以下几个：</p> <ol><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象；</li> <li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的；</li> <li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ol> <h3 id="如何实现数组和-list-转换"><a href="#如何实现数组和-list-转换" class="header-anchor">#</a> 如何实现数组和 List 转换？</h3> <ol><li>数组转 List：使用 Arrays.asList(array) 进行转换。</li> <li>List 转数组：使用 List 自带的 toArray() 方法。</li></ol> <h3 id="collection-和-collections-有什么区别"><a href="#collection-和-collections-有什么区别" class="header-anchor">#</a> Collection 和 Collections 有什么区别？</h3> <p>Collection 和 Collections 的区别如下：</p> <ol><li>Collection 是集合类的上级接口，继承它的主要有 List 和 Set；</li> <li>Collections 是针对集合类的一个帮助类，它提供了一些列的静态方法实现，如 Collections.sort() 排序、Collections.reverse() 逆序等。</li></ol> <h3 id="comparable-和-comparator-有什么区别"><a href="#comparable-和-comparator-有什么区别" class="header-anchor">#</a> Comparable 和 Comparator 有什么区别？</h3> <p>Comparable 和 Comparator 都是用来实现元素排序的，它们二者的区别如下：</p> <ol><li>Comparable 是“比较”的意思，而 Comparator 是“比较器”的意思；</li> <li>Comparable 是通过重写 compareTo 方法实现排序的，而 Comparator 是通过重写 compare 方法实现排序的；</li> <li>Comparable 必须由自定义类内部实现排序方法，而 Comparator 是外部定义并实现排序的；</li> <li>Comparator 用法更简单，它可以通过 JDK 1.8 中的 lambda 很轻松的实现排序功能。</li></ol> <h3 id="hashset-如何保证数据不可重复"><a href="#hashset-如何保证数据不可重复" class="header-anchor">#</a> HashSet 如何保证数据不可重复？</h3> <p>HashSet 保证数据不可重复的原因和 HashSet 添加数据的流程有关。</p> <p>添加的流程是：当将一个键值对放入 HashMap 时，首先根据 key 的 hashCode() 返回值决定该 Entry 的存储位置。如果有两个 key 的 hash 值相同，则会判断这两个元素 key 的 equals() 是否相同，如果相同就返回 true，说明是重复键值对，那么 HashSet 中 add() 方法的返回值会是 false，表示 HashSet 添加元素失败。因此，如果向 HashSet 中添加一个已经存在的元素，新添加的集合元素不会覆盖已有元素，从而保证了元素的不重复。如果不是重复元素，put 方法最终会返回 null，传递到 HashSet 的 add 方法就是添加成功。</p> <p>当将一个键值对放入 HashMap 时，首先根据 key 的 hashCode() 返回值决定该 Entry 的存储位置。如果有两个 key 的 hash 值相同，则会判断这两个元素 key 的 equals() 是否相同，如果相同就返回 true，说明是重复键值对，那么 HashSet 中 add() 方法的返回值会是 false，表示 HashSet 添加元素失败。因此，如果向 HashSet 中添加一个已经存在的元素，新添加的集合元素不会覆盖已有元素，从而保证了元素的不重复。如果不是重复元素，put 方法最终会返回 null，传递到 HashSet 的 add 方法就是添加成功。</p> <h3 id="hashmap-和-hashtable-有什么区别"><a href="#hashmap-和-hashtable-有什么区别" class="header-anchor">#</a> HashMap 和 Hashtable 有什么区别？</h3> <p>它们的区别体现在以下几个方面：</p> <ol><li>存储方面：HashMap 允许 key 和 value 为 null，而 Hashtable 不允许；</li> <li>线程安全方面：Hashtable 是线程安全的，而 HashMap 是非线程安全的；</li> <li>使用推荐方面：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ol> <h3 id="hashmap-底层是如何实现的"><a href="#hashmap-底层是如何实现的" class="header-anchor">#</a> HashMap 底层是如何实现的？</h3> <p>HashMap 在 JDK 1.7 和 JDK 1.8 的底层实现是不一样的。</p> <p>在 JDK 1.7 中，HashMap 使用的是数组 + 链表实现的，而 JDK 1.8 中使用的是数组 + 链表或红黑树实现的。</p> <h3 id="说一下-hashmap-新增流程"><a href="#说一下-hashmap-新增流程" class="header-anchor">#</a> 说一下 HashMap 新增流程？</h3> <p>简单来说 HashMap 的元素添加流程是，先将 key 值进行 hash 得到哈希值，根据哈希值得到元素位置，判断元素位置是否为空，如果为空直接插入，不为空判断是否为红黑树，如果是红黑树则直接插入，否则判断链表是否大于 8，且数组长度大于 64，如果满足这两个条件则把链表转成红黑树，然后插入元素，如果不满足这两个条件中的任意一个，则遍历链表进行插入。</p> <h3 id="为什么链表要升级为红黑树"><a href="#为什么链表要升级为红黑树" class="header-anchor">#</a> 为什么链表要升级为红黑树？</h3> <p>在 JDK 1.8 以上的版本中，当链表长度达到 8，并且数组长度大于等于 64 时，链表会转换为红黑树存储。因为链表超过一定长度之后查询效率就会很低，它的时间复杂度是 O(n)，而红黑树的时间复杂度是 O(logn)，因此引入红黑树可以加快 HashMap 在数据量比较大的情况下的查询效率。</p> <h3 id="什么情况红黑树会退化为链表"><a href="#什么情况红黑树会退化为链表" class="header-anchor">#</a> 什么情况红黑树会退化为链表？</h3> <p>当 TreeNode 长度小于 6 时，会退化为链表。</p> <h3 id="为什么-hashmap-要使用红黑树"><a href="#为什么-hashmap-要使用红黑树" class="header-anchor">#</a> 为什么 HashMap 要使用红黑树？</h3> <p>主要原因有以下几个：</p> <ol><li>二分查找树：它的左右节点不平衡，一开始就固定了 root，那么极端的情况下会成为链表结构；</li> <li>链表：链表长度越长，那么他的插入和查询效率都很低；</li> <li>红黑树：红黑树它的整体查找，增删节点的效率都是比较高的。</li></ol> <p>所以综合来说，使用红黑树最合适 HashMap 的存储。</p> <h3 id="hashmap-重要的参数有哪些"><a href="#hashmap-重要的参数有哪些" class="header-anchor">#</a> HashMap 重要的参数有哪些？</h3> <p>HashMap 有两个重要的参数：容量（Capacity）和加载因子（LoadFactor）。</p> <ol><li>容量（Capacity）：是指 HashMap 中桶的数量，默认的初始值为 16。</li> <li>加载因子（LoadFactor）：也被称为装载因子，或负载因子，LoadFactor 是用来判定 HashMap 是否扩容的依据，默认值为 0.75f，装载因子的计算公式 = HashMap 存放的 KV 总和（size）/ Capacity。</li></ol> <h3 id="为什么加载因子是-0-75"><a href="#为什么加载因子是-0-75" class="header-anchor">#</a> 为什么加载因子是 0.75？</h3> <p>这其实是出于容量和性能之间平衡的结果：</p> <ol><li>当加载因子设置比较大的时候，扩容的门槛就被提高了，扩容发生的频率比较低，占用的空间会比较小，但此时发生 Hash 冲突的几率就会提升，因此需要更复杂的数据结构来存储元素，这样对元素的操作时间就会增加，运行效率也会因此降低；</li> <li>而当加载因子值比较小的时候，扩容的门槛会比较低，因此会占用更多的空间，此时元素的存储就比较稀疏，发生哈希冲突的可能性就比较小，因此操作性能会比较高。</li></ol> <p>所以综合了以上情况，就取了一个 0.5 到 1.0 的平均数 0.75 作为加载因子。</p> <h3 id="hashmap-如何解决哈希冲突"><a href="#hashmap-如何解决哈希冲突" class="header-anchor">#</a> HashMap 如何解决哈希冲突？</h3> <p>HashMap 在 JDK 1.8 版本中是通过链式寻址法，以及红黑树来解决 Hash 冲突的问题。其中红黑树是为了优化 Hash 表的链表过长导致时间复杂度增加的问题，当链表长度大于等于 8，并且数组的容量大于 64 的时候，再向链表添加元素，就会触发链表向红黑树的一个转化。</p> <h3 id="concurrenthashmap-如何保证线程安全"><a href="#concurrenthashmap-如何保证线程安全" class="header-anchor">#</a> ConcurrentHashMap 如何保证线程安全？</h3> <p>ConcurrentHashMap 在 JDK 1.7 时是通过分段锁来保证线程安全的，而在 JDK 1.8 时是在头节点加锁，通过CAS + volatile 或 synchronized 的方式来保证线程安全的。</p> <h3 id="进程和线程有什么区别"><a href="#进程和线程有什么区别" class="header-anchor">#</a> 进程和线程有什么区别？</h3> <p>进程（Process）是操作系统分配资源的基本单位，一个进程拥有的资源有自己的堆、栈、虚存空间（页表）、文件描述符等信息。</p> <p>从编程的角度来理解进程，可以把它看作是一个类或一个 PCB（Process Control Block）进程控制块的结构体，这个结构体中大致包含以下几个内容：</p> <ol><li><p>进程编号 PID：进程的身份标识。</p></li> <li><p>进程的状态：</p> <p>新建状态</p> <p>就绪状态</p> <p>运行状态</p> <p>阻塞状态</p> <p>销毁状态</p></li> <li><p>执行优先级</p></li> <li><p>上下文</p></li> <li><p>内存地址</p></li></ol> <p>线程（Thread）是操作系统能够进行运算调度的基本单位。它包含在进程中，是进程中的实际运行单位。在 Unix System V 及 SunOS 中线程也被称为轻量进程（lightweight processes），但轻量进程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程。</p> <p>线程是轻量级的进程，一个进程中包含了多个线程，因此多个线程间可以共享进程资源。</p> <p>进程和线程的区别主要体现在以下几点：</p> <ol><li>从属关系不同：进程是正在运行程序的实例，进程中包含了线程，而线程中不能包含进程；</li> <li>描述侧重点不同：进程是操作系统分配资源的基本单位，而线程是操作系统调度的基本单位；</li> <li>共享资源不同：多个进程间不能共享资源，每个进程有自己的堆、栈、虚存空间（页表）、文件描述符等信息，而线程可以共享进程资源文件（堆和方法区）；</li> <li>上下文切换速度不同：线程上下文切换速度很快（上下文切换指的是从一个线程切换到另一个线程），而进程的上下文切换的速度比较慢；</li> <li>操纵者不同：一般情况下进程的操纵者是操作系统，而线程的操纵者是编程人员。</li></ol> <p>小结：简单来说，进程是操作系统分配资源的基本单位，而线程是操作系统调度的基本单位。一个进程中至少包含一个线程，线程不能独立于进程而存在。进程不能共享资源，而线程可以。线程可以看作是轻量级的进程，它们的主要区别体现在：从属关系、描述侧重点、共享资源、上下文切换速度和操纵对象等不同，线程可以看作是一个轻量级的“进程”。</p> <h3 id="多线程有什么优缺点"><a href="#多线程有什么优缺点" class="header-anchor">#</a> 多线程有什么优缺点？</h3> <p>多线程的优点是可以提高程序的执行性能。例如，有个 90 平方的房子，一个人打扫需要花费 30 分钟，三个人打扫就只需要 10 分钟，这三个人就是程序中的“多线程”。</p> <p>多线程的缺点是它带来了编码的复杂度，并且带来了线程安全性问题，也就是程序的执行不符合预期结果的问题。</p> <h3 id="线程的创建方式有哪些"><a href="#线程的创建方式有哪些" class="header-anchor">#</a> 线程的创建方式有哪些？</h3> <p>线程的创建，分为以下三种方式：</p> <ol><li>继承 Thread 类，重写 run 方法；</li> <li>实现 Runnable 接口，实现 run 方法；</li> <li>实现 Callable 接口，实现 call 方法。</li></ol> <ul><li>继承 Thread 类</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyThread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Thread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>实现 Runnable 接口</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyRunnable</span> runnable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyRunnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>runnable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyRunnable</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Runnable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li>实现 Callable 接口</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">ThreadTest</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">MyCallable</span> callable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyCallable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 定义返回结果</span>
        <span class="token class-name">FutureTask</span><span class="token operator">&lt;</span><span class="token class-name">String</span>### result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 执行程序</span>
        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 输出返回结果</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">MyCallable</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Callable&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">return</span> <span class="token string">&quot;Success&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="如何简单的使用线程"><a href="#如何简单的使用线程" class="header-anchor">#</a> 如何简单的使用线程？</h3> <p>JDK 8 之后可以使用 Lambda 表达式很方便地创建线程，请参考以下代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span>### <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Lambda Of Thread.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="用户线程和守护线程有什么区别"><a href="#用户线程和守护线程有什么区别" class="header-anchor">#</a> 用户线程和守护线程有什么区别？</h3> <p>在 Java 语言中，线程分为两类：用户线程和守护线程，默认情况下我们创建的线程或线程池都是用户线程，所以用户线程也被称之为普通线程。</p> <p>想要查看线程到底是用户线程还是守护线程，可以通过 Thread.isDaemon() 方法来判断，如果返回的结果是 true 则为守护线程，反之则为用户线程。</p> <p>守护线程（Daemon Thread）也被称之为后台线程或服务线程，守护线程是为用户线程服务的，当程序中的用户线程全部执行结束之后，守护线程也会跟随结束。</p> <p>守护线程的角色就像“服务员”，而用户线程的角色就像“顾客”，当“顾客”全部走了之后（全部执行结束），那“服务员”（守护线程）也就没有了存在的意义，所以当一个程序中的全部用户线程都结束执行之后，那么无论守护线程是否还在工作都会随着用户线程一块结束，整个程序也会随之结束运行。</p> <p>小结：默认情况下我们创建的线程或线程池都是用户线程，守护线程是为用户线程服务的，当一个程序中的所有用户线程都执行完成之后程序就会结束运行，程序结束运行时不会管守护线程是否正在运行，由此我们可以看出守护线程在 Java 体系中权重是比较低的，这就是守护线程和用户线程的区别。</p> <h3 id="线程常用的方法有哪些"><a href="#线程常用的方法有哪些" class="header-anchor">#</a> 线程常用的方法有哪些？</h3> <p>线程常用的方法有以下几个：</p> <ol><li>start()：启动线程；</li> <li>wait()：实现线程等待；</li> <li>notify()/notifyAll()：唤醒线程；</li> <li>sleep(xxx)：带有结束时间让线程休眠的方法；</li> <li>yield()：交出 CPU 执行权。</li></ol> <h3 id="start-和-run-方法有什么区别"><a href="#start-和-run-方法有什么区别" class="header-anchor">#</a> start 和 run 方法有什么区别？</h3> <p>简单来说，run 方法是对象的普通方法，而 start 方法是开启新线程的方法。它们的区别体现在以下几点：</p> <ol><li>方法性质不同：run 是一个普通方法，而 start 是开启新线程的方法。</li> <li>执行速度不同：调用 run 方法会立即执行任务，调用 start 方法是将线程的状态改为就绪状态，不会立即执行。</li> <li>调用次数不同：run 方法可以被重复调用，而 start 方法只能被调用一次。</li></ol> <p>start 方法之所以不能被重复调用的原因是，线程的状态是不可逆的，Thread 在 start 的实现源码中做了判断，如果线程不是新建状态 NEW，则会抛出非法线程状态异常 IllegalThreadStateException。</p> <h3 id="wait-方法和-sleep-方法有什么区别"><a href="#wait-方法和-sleep-方法有什么区别" class="header-anchor">#</a> wait 方法和 sleep 方法有什么区别？</h3> <p>sleep 和 wait 方法都可以让线程进入休眠状态，但二者是完全不同的，它们的区别主要体现在以下几点。</p> <ul><li>使用语法不同</li></ul> <p>wait 方法必须配合 synchronized 一起使用，不然在运行时就会抛出 IllegalMonitorStateException 的异常。</p> <p>而 sleep 可以单独使用，无需配合 synchronized 一起使用。</p> <ul><li>所属类不同</li></ul> <p>wait 方法属于 Object 类的方法，而 sleep 属于 Thread 类的方法。</p> <ul><li>唤醒方式不同</li></ul> <p>wait 方法执行时会主动的释放锁，而 sleep 方法则不会释放锁。</p> <h3 id="说一下线程的生命周期"><a href="#说一下线程的生命周期" class="header-anchor">#</a> 说一下线程的生命周期？</h3> <p>线程的生命周期指的是线程从创建到销毁的整个过程，通常情况下线程的生命周期有以下 5 种：</p> <ol><li>初始状态</li> <li>可运行状态</li> <li>运行状态</li> <li>休眠状态</li> <li>终止状态</li></ol> <h3 id="怎么终止线程"><a href="#怎么终止线程" class="header-anchor">#</a> 怎么终止线程？</h3> <p>在 Java 中终止线程的实现方法有以下 2 种：</p> <ol><li>使用 interrupt 中断线程方法，此方法是发送一个中断信号给线程，它可以及时响应中断，也是最推荐使用的方法；</li> <li>最后是 stop 方法，虽然它也可以停止线程，但此方法已经是过时的不建议使用的方法，在 Java 最新版本中已经被直接移除了，所以不建议使用。</li></ol> <h3 id="线程和线程池有什么区别"><a href="#线程和线程池有什么区别" class="header-anchor">#</a> 线程和线程池有什么区别？</h3> <p>线程池（Thread Pool）：把一个或多个线程通过统一的方式进行调度和重复使用的技术，避免了因为线程过多而带来使用上的开销。</p> <p>相比于线程来说，线程池具备以下优点：</p> <ol><li>可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。</li> <li>避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。</li> <li>支持更多功能，比如延迟任务线程池（newScheduledThreadPool）和缓存线程池（newCachedThreadPool）等。</li></ol> <h3 id="如何创建线程池"><a href="#如何创建线程池" class="header-anchor">#</a> 如何创建线程池？</h3> <p>线程池的创建可以分为以下两类：</p> <ol><li>通过 ThreadPoolExecutor 手动创建线程池。</li> <li>通过 Executors 执行器自动创建线程池。</li></ol> <p>而以上两类创建线程池的方式，又有 7 种具体实现方法，这 7 种实现方法分别是：</p> <ol><li>Executors.newFixedThreadPool：创建一个固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待。</li> <li>Executors.newCachedThreadPool：创建一个可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程。</li> <li>Executors.newSingleThreadExecutor：创建单个线程数的线程池，它可以保证先进先出的执行顺序。</li> <li>Executors.newScheduledThreadPool：创建一个可以执行延迟任务的线程池。</li> <li>Executors.newSingleThreadScheduledExecutor：创建一个单线程的可以执行延迟任务的线程池。</li> <li>Executors.newWorkStealingPool：创建一个抢占式执行的线程池（任务执行顺序不确定）。</li> <li>ThreadPoolExecutor：手动创建线程池的方式，它创建时最多可以设置 7 个参数。</li></ol> <h3 id="推荐使用哪种方式来创建线程池"><a href="#推荐使用哪种方式来创建线程池" class="header-anchor">#</a> 推荐使用哪种方式来创建线程池？</h3> <p>推荐使用 ThreadPoolExecutor 的方式来创建线程池，这样的处理方式让写的读者更加明确线程池的运行规则，规避资源耗尽的风险。</p> <p>Executors 创建线程池的弊端如下：</p> <ol><li>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM；</li> <li>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</li></ol> <h3 id="说一下-threadpoolexecutor-的参数含义"><a href="#说一下-threadpoolexecutor-的参数含义" class="header-anchor">#</a> 说一下 ThreadPoolExecutor 的参数含义？</h3> <p>ThreadPoolExecutor 最多支持 7 个参数的设置，如下代码所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span>
                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>
                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span>
                          <span class="token class-name">BlockingQueue</span><span class="token operator">&lt;</span><span class="token class-name">Runnable</span>### workQueue<span class="token punctuation">,</span>
                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span>
                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
        <span class="token comment">// maximumPoolSize 必须大于 0，且必须大于 corePoolSize</span>
        maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>
        maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>
        keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> threadFactory <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> handler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>acc <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span>
            <span class="token keyword">null</span> <span class="token operator">:</span>
            <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>这 7 个参数的含义如下：</p> <ol><li>第 1 个参数：corePoolSize 表示线程池的常驻核心线程数。如果设置为 0，则表示在没有任何任务时，销毁线程池；如果大于 0，即使没有任务时也会保证线程池的线程数量等于此值。但需要注意，此值如果设置的比较小，则会频繁的创建和销毁线程（创建和销毁的原因会在本课时的下半部分讲到）；如果设置的比较大，则会浪费系统资源，所以开发者需要根据自己的实际业务来调整此值；</li> <li>第 2 个参数：maximumPoolSize 表示线程池在任务最多时，最大可以创建的线程数。官方规定此值必须大于 0，也必须大于等于 corePoolSize，此值只有在任务比较多，且不能存放在任务队列时，才会用到；</li> <li>第 3 个参数：keepAliveTime 表示线程的存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止，如果 maximumPoolSize 等于 corePoolSize，那么线程池在空闲的时候也不会销毁任何线程；</li> <li>第 4 个参数：unit 表示存活时间的单位，它是配合 keepAliveTime 参数共同使用的；</li> <li>第 5 个参数：workQueue 表示线程池执行的任务队列，当线程池的所有线程都在处理任务时，如果来了新任务就会缓存到此任务队列中排队等待执行；</li> <li>第 6 个参数：threadFactory 表示线程的创建工厂，此参数一般用的比较少，我们通常在创建线程池时不指定此参数，它会使用默认的线程创建工厂的方法来创建线程；</li> <li>第 7 个参数：RejectedExecutionHandler 表示指定线程池的拒绝策略，当线程池的任务已经在缓存队列 workQueue 中存储满了之后，并且不能创建新的线程来执行此任务时，就会用到此拒绝策略，它属于一种限流保护的机制。</li></ol> <h3 id="说一下线程池的执行流程"><a href="#说一下线程池的执行流程" class="header-anchor">#</a> 说一下线程池的执行流程？</h3> <p>线程池的执行流程是：先判断当前线程数是否大于核心线程数？如果结果为 false，则新建线程并执行任务；如果结果为 true，则判断任务队列是否已满？如果结果为 false，则把任务添加到任务队列中等待线程执行，否则则判断当前线程数量是否超过最大线程数？如果结果为 false，则新建线程执行此任务，否则将执行线程池的拒绝策略。</p> <h3 id="线程池的拒绝策略都有哪些"><a href="#线程池的拒绝策略都有哪些" class="header-anchor">#</a> 线程池的拒绝策略都有哪些</h3> <p>当任务过多且线程池的任务队列已满时，此时就会执行线程池的拒绝策略，线程池的拒绝策略默认有以下 4 种：</p> <ol><li>AbortPolicy：中止策略，线程池会抛出异常并中止执行此任务；</li> <li>CallerRunsPolicy：把任务交给添加此任务的（main）线程来执行；</li> <li>DiscardPolicy：忽略此任务，忽略最新的一个任务；</li> <li>DiscardOldestPolicy：忽略最早的任务，最先加入队列的任务。</li></ol> <p>默认的拒绝策略为 AbortPolicy 中止策略。</p> <h3 id="如何实现自定义拒绝策略"><a href="#如何实现自定义拒绝策略" class="header-anchor">#</a> 如何实现自定义拒绝策略？</h3> <p>除了 JDK 提供的四种拒绝策略之外，我们还可以实现通过 new RejectedExecutionHandler，并重写 rejectedExecution 方法来实现自定义拒绝策略，实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">RejectedExecutionHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rejectedExecution</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> r<span class="token punctuation">,</span> <span class="token class-name">ThreadPoolExecutor</span> executor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;自定义拒绝策略&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="线程池中-shutdownnow-和-shutdown-有什么区别"><a href="#线程池中-shutdownnow-和-shutdown-有什么区别" class="header-anchor">#</a> 线程池中 shutdownNow() 和 shutdown() 有什么区别？</h3> <p>shutdownNow() 和 shutdown() 都是用来终止线程池的，它们的区别是，使用 shutdown() 程序不会报错，也不会立即终止线程，它会等待线程池中的缓存任务执行完之后再退出，执行了 shutdown() 之后就不能给线程池添加新任务了；shutdownNow() 会试图立马停止任务，如果线程池中还有缓存任务正在执行，则会抛出 java.lang.InterruptedException: sleep interrupted  异常。</p> <h3 id="多线程存在什么问题"><a href="#多线程存在什么问题" class="header-anchor">#</a> 多线程存在什么问题？</h3> <p>多线程的优点可以同时执行多个任务，而缺点是多线程存在线程安全问题，也就是线程的执行不符合预期结果的问题。</p> <h3 id="为什么会有线程安全问题"><a href="#为什么会有线程安全问题" class="header-anchor">#</a> 为什么会有线程安全问题？</h3> <p>导致线程安全问题的因素有以下 5 个：</p> <ol><li>多线程抢占式执行；</li> <li>多线程同时修改同一个变量；</li> <li>非原子性操作：原子性操作是指操作不能再被分割就叫原子性操作，而导致线程安全性问题的一大因素就是非原子性操作；</li> <li>内存可见性：多个线程同时操作统一变量，但因为某些原因导致变量已经被一个线程修改，但另一个线程不可见，从而导致了线程安全性问题；</li> <li>指令重排序：指令重排序是指 Java 程序为了提高程序的执行速度，所以会对一下操作进行合并和优化的操作，比如某些操作本来的顺序是 A -### B -### C，但被指令重排序之后就变成了 A -### C -### B，但这样重排之后就会导致程序的执行结果和预期的结果不相符的问题。</li></ol> <h3 id="如何解决线程安全问题"><a href="#如何解决线程安全问题" class="header-anchor">#</a> 如何解决线程安全问题？</h3> <p>在 Java 中，解决线程安全问题有以下 3 种手段：</p> <ol><li><p>使用线程安全类，比如 AtomicInteger；</p></li> <li><p>加锁排队执行</p> <p>使用 synchronized 加锁；</p> <p>使用 ReentrantLock 加锁；</p></li> <li><p>使用线程本地变量 ThreadLocal。</p></li></ol> <p>线程安全类通常是使用锁机制（乐观锁或悲观锁）来保证程序的正常执行的。</p> <h3 id="synchronized-有几种用法"><a href="#synchronized-有几种用法" class="header-anchor">#</a> synchronized 有几种用法？</h3> <p>synchronized 常见用法有 3 种：</p> <ol><li>使用 synchronized 修饰普通方法；</li> <li>使用 synchronized 修饰静态方法；</li> <li>使用 synchronized 修饰代码块。</li></ol> <h3 id="synchronized-修饰静态方法和普通方法有什么区别吗"><a href="#synchronized-修饰静态方法和普通方法有什么区别吗" class="header-anchor">#</a> synchronized 修饰静态方法和普通方法有什么区别吗？</h3> <p>synchronized 修饰普通方法和静态方法看似相同，但二者完全不同，对于静态方法来说 synchronized 加锁是全局的，也就是整个程序运行期间，所有调用这个静态方法的对象都是互斥的，而普通方法是针对对象级别的，不同的对象对应着不同的锁。</p> <h3 id="jvm-和-jdk、jre-有什么区别"><a href="#jvm-和-jdk、jre-有什么区别" class="header-anchor">#</a> JVM 和 JDK、JRE 有什么区别？</h3> <p>它们的定义和作用是不同的</p> <ol><li>JVM 是 Java Virtual Machine 的缩写，翻译为中文就是“Java虚拟机”，它是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现 Java 程序的运行，简单来说 JVM 是用来解析和运行 Java 程序的；</li> <li>JDK(Java Development Kit)，即 Java 开发工具包，是一个编写 Java 应用程序的开发环境。JDK 是整个 Java 的核心，包括了JRE（Java运行环境）与一些Java开发工具（例如：jconsole、javac、java、javadoc、native2ascii、jar等）。JDK=JRE+Java开发工具（编译器、调试器等）；</li> <li>JRE(Java Runtime Environment)，即 Java 运行环境，支持 Java 程序运行的标准环境，包括了 JVM（Java虚拟机）的标准实现以及 Java 基础&amp;核心类库。JRE=JVM+Java 基础&amp;核心类库。</li></ol> <p>所以，简单来说：</p> <ol><li>JVM=Java 运行器；</li> <li>JRE=JVM + Java 基础&amp;核心类库；</li> <li>JDK=JRE + Java 开发工具（编译器、调试器等）。</li></ol> <h3 id="jvm-是如何工作的"><a href="#jvm-是如何工作的" class="header-anchor">#</a> JVM 是如何工作的？</h3> <p>JVM 整体的大概执行流程是这样的：程序在执行之前先要把java代码转换成字节码（class文件），JVM 首先需要把字节码通过一定的方式类加载器（ClassLoader）把文件加载到内存中运行时数据区（Runtime Data Area），而字节码文件是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器，执行引擎（Execution Engine）将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用其他语言的接口，本地库接口（Native Interface）来实现整个程序的功能。</p> <p>总结来看， JVM 主要通过分为以下 4 个部分，来执行 Java 程序的，它们分别是：</p> <ol><li>类加载器（ClassLoader）</li> <li>运行时数据区（Runtime Data Area）</li> <li>执行引擎（Execution Engine）</li> <li>本地库接口（Native Interface）</li></ol> <h3 id="说一下类加载机制"><a href="#说一下类加载机制" class="header-anchor">#</a> 说一下类加载机制？</h3> <p>类加载总共有 5 个步骤，可以分为 3 大步：</p> <ol><li>加载</li> <li>验证</li> <li>准备</li> <li>解析</li> <li>初始化</li></ol> <p>它们的具体细节如下。</p> <ul><li>加载</li></ul> <p>加载（Loading）阶段是整个“类加载”（Class Loading）过程中的一个阶段，它和类加载 Class Loading 是不同的，一个是加载 Loading 另一个是类加载 Class Loading，所以不要把二者搞混了。</p> <p>在加载 Loading 阶段，Java 虚拟机需要完成以下 3 件事：</p> <ol><li>通过一个类的全限定名来获取定义此类的二进制字节流；</li> <li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li> <li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol> <ul><li>验证</li></ul> <p>验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节 流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信 息被当作代码运行后不会危害虚拟机自身的安全。</p> <p>验证选项：</p> <ol><li>文件格式验证</li> <li>字节码验证</li> <li>符号引用验证...</li></ol> <ul><li>准备</li></ul> <p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。</p> <p>比如此时有这样一行代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>它是初始化 value 的 int 值为 0，而非 123。</p> <ul><li>解析</li></ul> <p>解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程，也就是初始化常量的过程。</p> <ul><li>初始化</li></ul> <p>初始化阶段，Java 虚拟机真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。初始化阶段就是执行类构造器方法的过程。</p> <h3 id="什么是双亲委派模型"><a href="#什么是双亲委派模型" class="header-anchor">#</a> 什么是双亲委派模型？</h3> <p>双亲委派模型指的是：当一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最 终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无 法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。</p> <h3 id="说一下-jvm-的内存布局"><a href="#说一下-jvm-的内存布局" class="header-anchor">#</a> 说一下 JVM 的内存布局？</h3> <p>通常所说的 JVM 内存布局，一般指的是 JVM 运行时数据区（Runtime Data Area），也就是当字节码被类加载器加载之后的执行区域划分。</p> <p>《Java虚拟机规范》中将 JVM 运行时数据区域划分为以下 5 部分：</p> <ol><li>程序计数器（Program Counter Register）</li> <li>Java虚拟机栈（Java Virtual Machine Stacks）</li> <li>本地方法栈（Native Method Stack）</li> <li>Java 堆（Java Heap）</li> <li>方法区（Methed Area）</li></ol> <h3 id="程序计数器有什么特点"><a href="#程序计数器有什么特点" class="header-anchor">#</a> 程序计数器有什么特点？</h3> <p>程序计数器有以下 4 个特点：</p> <ol><li>执行速度最快：程序计数器中真实记录的是下一行任务的执行指令，因此程序计数器是 JVM 运行时数据区中执行最快的一块区域；</li> <li>线程非共享：程序计数器记录的是每个线程的执行行号，所以每个线程都拥有自己的程序计数器，所以此区域不是线程共享的，而是线程私有的；</li> <li>不存在 GC：程序计数器不存在 GC（垃圾回收）。</li> <li>无 OOM：OOM 是 Out of Memory 的缩写，译为内存溢出。程序计数器是 JVM 内存布局中，唯一一个不会产生 OOM 的区域。</li></ol> <h3 id="java-虚拟机栈的作用是什么"><a href="#java-虚拟机栈的作用是什么" class="header-anchor">#</a> Java 虚拟机栈的作用是什么？</h3> <p>Java 虚拟机栈保存了：方法的局部变量、方法执行中的部分结果，并参与方法的调用和返回，这些内容指导者 Java 程序的运行。</p> <p>也就是说，栈是运行时单位，而堆是存储单位。栈解决的是程序运行的问题，即程序如何执行？或者说如何处理数据。而堆解决的是数据存储的问题，即数据怎么放？放在哪儿的问题。</p> <h3 id="什么情况下会出现栈溢出"><a href="#什么情况下会出现栈溢出" class="header-anchor">#</a> 什么情况下会出现栈溢出？</h3> <p>导致栈（Java 虚拟机栈）溢出最常见的情况就是死循环和无限递归，方法自己调自己，这样 Java 虚拟机栈就会只入栈不出栈，当到达 Java 虚拟机栈的最大数之后就会出现 StackOverflowError 异常。</p> <h3 id="堆和栈有什么区别"><a href="#堆和栈有什么区别" class="header-anchor">#</a> 堆和栈有什么区别？</h3> <p>堆是 Java 虚拟机的主要存储单位，Java 中所有的对象和数组都是保存在此区域的；而栈是 Java 虚拟机的运行单位。</p> <p>堆解决的是数据存储的问题，即数据怎么放？放在哪儿的问题；而栈解决的是程序运行的问题，即程序如何执行？或者说如何处理数据。</p> <h3 id="堆有什么特点"><a href="#堆有什么特点" class="header-anchor">#</a> 堆有什么特点？</h3> <p>堆的特点如下：</p> <ol><li>线程共享：堆是线程共享的，堆上的对象可能被多个线程同时访问；</li> <li>占用空间最大：堆是 JVM 内存布局中最大的一块区域，Java 中所有的对象和数组都是保存在此区域；</li> <li>最频繁的 GC 区域：堆也是垃圾回收器进行垃圾回收最频繁的一块区域；</li> <li>产生 OOM：当堆空间不足时，会产生 OutOfMemoryError 异常。</li></ol> <h3 id="内存溢出和内存泄漏有什么区别"><a href="#内存溢出和内存泄漏有什么区别" class="header-anchor">#</a> 内存溢出和内存泄漏有什么区别？</h3> <p>内存泄漏和内存溢出是两个问题，他们是完全不同的，先来看一下二者的定义：</p> <ol><li>内存泄漏：当对象不会再被程序使用，但是 GC 又不能回收他们的情况，就叫做内存泄漏；</li> <li>内存溢出：当程序出现严重的内存泄漏问题，最终会导致内存使用不足的情况叫做内存溢出。</li></ol> <p>因此可以得出：内存泄漏问题会导致内存溢出，内存溢出通常会伴随着内存泄漏，但二者是完全不同的两个概念。</p> <h3 id="方法区中存储了什么内容"><a href="#方法区中存储了什么内容" class="header-anchor">#</a> 方法区中存储了什么内容？</h3> <p>方法区中存储了虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据的。</p> <h3 id="方法区和永久代是一个东西吗"><a href="#方法区和永久代是一个东西吗" class="header-anchor">#</a> 方法区和永久代是一个东西吗？</h3> <p>不是一个东西，在《Java虚拟机规范中》把此区域称之为“方法区”，而在 HotSpot 虚拟机的实现中，在 JDK 7 时此区域叫做永久代（PermGen），JDK 8 中叫做元空间（Metaspace）。</p> <p>永久代（PermGen）和元空间（Metaspace）是 HotSpot 中对《Java虚拟机规范》中方法区的实现，它们三者之间的关系就好比，对于一辆汽车来说它定义了一个部分叫做“动能提供装置”，但对于不同的汽车有不同的实现技术，比如对于燃油车来说，它的“动能提供装置”的实现技术就是汽油发动机（简称发动机），而对于电动汽车来说，它的“动能提供装置”的实现就是电动发动机（简称电机），发动机和电机就相当于永久代和元空间一样，它是对于“制动器”也就是方法区定义的实现。</p> <h3 id="jdk-1-8-元空间有什么变化"><a href="#jdk-1-8-元空间有什么变化" class="header-anchor">#</a> JDK 1.8 元空间有什么变化？</h3> <p>JDK 1.8 之后，HotSpot 虚拟机开始使用元空间（Meta Space）来实现方法区了，JDK 1.8 元空间的主要变化有两个：</p> <ol><li>元空间变为了本地内存；</li> <li>将字符串常量池移动到了堆中。</li></ol> <h3 id="为什么要使用元空间替代永久代"><a href="#为什么要使用元空间替代永久代" class="header-anchor">#</a> 为什么要使用元空间替代永久代？</h3> <p>之所以要取消“永久代”是因为 Java 官方收购了 JRockit，之后在将 JRockit 和 HotSpot 进行整合时，因为 JRockit 中没有“永久代”，所以把永久代给移除了。</p> <h3 id="如何判断对象的是否需要被回收"><a href="#如何判断对象的是否需要被回收" class="header-anchor">#</a> 如何判断对象的是否需要被回收？</h3> <p>我们只需要判断不可用对象，然后在垃圾回收时，将不可用对象回收即可。</p> <p>判断不可用对象有两种常见的算法：</p> <ol><li>引用计数算法</li> <li>可达性分析算法</li></ol> <ul><li>引用计数器算法</li></ul> <p>引用计数器算法的实现思路是，给对象增加一个引用计数器，每当有一个地方引用它时，计数器就 +1；当引用失效时，计数器就 -1；任何时刻计数器为 0 的对象就是不能再被使用的。</p> <p>引用计数法的优点：实现简单，判定效率也比较高。</p> <p>引用计数法的缺点：是引用计数法无法解决对象的循环引用问题。</p> <ul><li>可达性分析算法</li></ul> <p>可达性分析算法是通过一系列称为&quot;GC Roots&quot;的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称之为&quot;引用链&quot;，当一个对象到GC Roots没有任何的引用链相连时(从GC Roots到这个对象不可达)时，证明此对象是不可用的。</p> <p>目前主流的 Java 虚拟机使用的都是可达性分析算法来判断不可用对象的。</p> <h3 id="说一下常用的垃圾回收算法"><a href="#说一下常用的垃圾回收算法" class="header-anchor">#</a> 说一下常用的垃圾回收算法？</h3> <p>常见垃圾回收算法有：</p> <ol><li>标记-清除算法：&quot;标记-清除&quot;算法是最基础的收集算法。算法分为&quot;标记&quot;和&quot;清除&quot;两个阶段 : 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。后续的收集算法都是基于这种思路并对其不足加以改进而已；</li> <li>复制算法：&quot;复制&quot;算法是为了解决&quot;标记-清理&quot;的效率问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这块内存需要进行垃圾回收时，会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。这样做的好处是每次都是对整个半区进行内存回收，内存分配时也就不需要考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配即可。此算法实现简单，运行高效；</li> <li>标记-整理算法：标记-整理算法也是分为两个阶段“标记”和“整理”，其中标记仍与标记-清除算法的“标记”过程实现是一致的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存；</li> <li>分代算法：分代算法是通过区域划分，实现不同区域和不同的垃圾回收策略，从而实现更好的垃圾回收，这就时分代算法的设计思想。</li></ol> <h3 id="标记-清除算法、标记-整理和复制算法有什么特点"><a href="#标记-清除算法、标记-整理和复制算法有什么特点" class="header-anchor">#</a> 标记-清除算法、标记-整理和复制算法有什么特点？</h3> <p>标记-清除算法、标记-整理和复制算法有以下几个不足：</p> <ol><li>标记-清除算法会产生内存碎片问题，在标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行中需要分配较大对象时，无法找到足够连续内存而不得不提前触发另一次垃圾收集；</li> <li>标记-整理算法是在对象存活率较高时，会进行比较多的复制操作，效率会变低；</li> <li>复制算法的效率比较高，但对内存的利用率不高。</li></ol> <h3 id="mysql-是如何运行的"><a href="#mysql-是如何运行的" class="header-anchor">#</a> MySQL 是如何运行的？</h3> <p>MySQL 执行流程要经历的步骤有：</p> <p>1、授权认证</p> <p>2、语法分析</p> <p>3、生成执行计划</p> <p>4、验证权限，执行 SQL 语句并将结果返回给客户端</p> <ul><li>授权认证</li></ul> <p>如果使用的是命令行工具，通常需要输入如下信息：</p> <p>mysql  -h  主机名(IP)  -u  用户名 -P 端口 -p</p> <p>其中：</p> <p>1、-h 表示要连接的数据库服务器的主机名或者 IP 信息；</p> <p>2、-u 表示数据库的用户名称；</p> <p>3、-P 表示数据库服务器的端口号；</p> <p>4、小写的 -p 表示需要输入数据库的密码。</p> <p>当输入正确密码之后可以连接到数据库了，如果密码输入错误，则会提示“Access denied for user 'xxx'@'xxx' (using password: YES)”密码错误信息。</p> <ul><li>语法分析</li></ul> <p>当连接服务器端成功之后就可以正常的执行 SQL 命令了，MySQL 服务器拿到 SQL 命令之后，会使用 MySQL 的分析器解析 SQL 指令，同时会根据语法分析器验证 SQL 指令，查询 SQL 指令是否满足 MySQL 的语法规则。如果不支持此语法，则会提示“SQL syntax”语法错误信息。</p> <p>生成执行计划</p> <p>当分析器验证并解析 SQL 命令之后，会进入优化器阶段，执行生成计划，并设置相应的索引**；**当上面的这些步骤都执行完之后，就进入了执行器阶段，并开始正式执行 SQL 命令。</p> <p>验证权限执行 SQL 语句</p> <p>同样在执行命令之前，它会先对你的执行命令进行权限查询，看看是否有操作某个表的权限，如果有相应的权限，执行器就去调用 MySQL 数据库引擎提供的接口，执行相应的命令；如果是非查询操作会记录对应的操作日志，再命令执行完成之后返回结果给客户端，这就是整个 MySQL 操作的完整流程。</p> <h3 id="关系型和非关系型数据库的区别"><a href="#关系型和非关系型数据库的区别" class="header-anchor">#</a> 关系型和非关系型数据库的区别？</h3> <p>关系型数据库的优点：</p> <p>1、容易理解，因为它采用了关系模型来组织数据；</p> <p>2、可以保持数据的一致性；</p> <p>3、数据更新的开销比较小；</p> <p>4、支持复杂查询（带 where 子句的查询）。</p> <p>非关系型数据库（NOSQL）的优点：</p> <p>1、无需经过 SQL 层的解析，读写效率高；</p> <p>2、基于键值对，读写性能很高，易于扩展；</p> <p>3、可以支持多种类型数据的存储，如图片，文档等等；</p> <p>4、扩展（可分为内存性数据库以及文档型数据库，比如 Redis，MongoDB，HBase 等，适合场景：数据量大高可用的日志系统/地理位置存储系统）。</p> <h3 id="说一下数据库的三范式"><a href="#说一下数据库的三范式" class="header-anchor">#</a> 说一下数据库的三范式？</h3> <p>数据库的三范式主要是为了保证数据库表和字段设计的合理性和规范性的，它的内容如下：</p> <p>1、第一范式规定表中的每个列都应该是不可分割的最小单元；</p> <p>2、第二范式是在满足第一范式的基础上，规定表中的非主键列不存在对主键的部分依赖；</p> <p>3、第三范式是在满足第一范式和第二范式的基础上，规定表中的列不存在对非主键列的传递依赖。</p> <p>使用数据库三范式的优势是：表的结构更简单、优雅，表的逻辑和条理性更强，并且使用三范式可以很大程度的减少表中的冗余数据，很好的节省了数据库的存储资源。</p> <h3 id="mysql-常用引擎有哪些"><a href="#mysql-常用引擎有哪些" class="header-anchor">#</a> MySQL 常用引擎有哪些？</h3> <p>MySQL 最常用的存储引擎有以下 3 种：</p> <p>1、InnoDB：MySQL 5.1 之后默认的存储引擎，它支持事务、支持外键、支持崩溃修复和自增列。如果对业务的完整性要求较高，比如张三给李四转账，需要减张三的钱，同时给李四加钱，这时候只能全部执行成功或全部执行失败，此时可以通过 InnoDB 来控制事务的提交和回滚，从而保证业务的完整性。InnoDB 的优势是支持事务、支持外键、支持崩溃修复和自增列；它的缺点是读写效率较差、占用的数据空间较大；</p> <p>2、MyISAM：MySQL 5.1 之前默认的数据库引擎，读取效率较高，占用数据空间较少，但不支持事务、不支持行级锁、不支持外键等特性。因为不支持行级锁，因此在添加和修改操作时，会执行锁表操作，所以它的写入效率较低。MyISAM 引擎保存了单独的索引文件 .myi，且它的索引是直接定位到 OFFSET 的，而 InnoDB 没有单独的物理索引存储文件，且 InnoDB 索引寻址是先定位到块数据，再定位到行数据，所以 MyISAM 的查询效率是比 InnoDB 的查询效率要高。但它不支持事务、不支持外键，所以它的适用场景是读多写少，且对完整性要求不高的业务场景；</p> <p>3、MEMORY：内存型数据库引擎，所有的数据都存储在内存中，因此它的读写效率很高，但 MySQL 服务重启之后数据会丢失。它同样不支持事务、不支持外键。MEMORY 支持 Hash 索引或 B 树索引，其中 Hash 索引是基于 key 查询的，因此查询效率特别高，但如果是基于范围查询的效率就比较低了。而前面两种存储引擎是基于 B+ 树的数据结构实现了。MEMORY 读写性能很高，但 MySQL 服务重启之后数据会丢失，它不支持事务和外键。适用场景是读写效率要求高，但对数据丢失不敏感的业务场景。</p> <h3 id="innodb-和-myisam-有什么区别"><a href="#innodb-和-myisam-有什么区别" class="header-anchor">#</a> InnoDB 和 MyISAM 有什么区别？</h3> <p>InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们其他主要区别如下：</p> <p>1、InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</p> <p>2、InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</p> <p>3、InnoDB 支持外键，MyISAM 不支持外键；</p> <p>4、MyISAM 性能比 InnoDB 高；</p> <p>5、MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</p> <p>6、InnoDB 主键查询性能高于 MyISAM。</p> <h3 id="mysql-有哪些索引类型"><a href="#mysql-有哪些索引类型" class="header-anchor">#</a> MySQL 有哪些索引类型？</h3> <p>MySQL 的索引有两种分类方式：逻辑分类和物理分类。</p> <p>按照逻辑分类，索引可分为：</p> <p>1、主键索引：一张表只能有一个主键索引，不允许重复、不允许为 NULL；</p> <p>2、唯一索引：数据列不允许重复，允许为 NULL 值，一张表可有多个唯一索引，但是一个唯一索引只能包含一列，比如身份证号码、卡号等都可以作为唯一索引；</p> <p>3、普通索引：一张表可以创建多个普通索引，一个普通索引可以包含多个字段，允许数据重复，允许 NULL 值插入；</p> <p>4、全文索引：让搜索关键词更高效的一种索引。</p> <p>按照物理分类，索引可分为：</p> <p>1、聚簇索引：一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为 NULL 的唯一索引，如果还是没有的话，就采用 Innodb 存储引擎为每行数据内置的 6 字节 ROWID 作为聚簇索引或聚集索引。每张表只有一个聚集索引，因为聚集索引的键值的逻辑顺序决定了表中相应行的物理顺序。聚集索引在精确查找和范围查找方面有良好的性能表现（相比于普通索引和全表扫描），聚集索引就显得弥足珍贵，聚集索引选择还是要慎重的（一般不会让没有语义的自增 id 充当聚集索引）；</p> <p>2、非聚簇索引：该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同（非主键的那一列），一个表中可以拥有多个非聚簇索引。</p> <h3 id="聚簇索引和非聚簇索引有什么区别"><a href="#聚簇索引和非聚簇索引有什么区别" class="header-anchor">#</a> 聚簇索引和非聚簇索引有什么区别？</h3> <p>聚簇索引和非聚簇索引都是 InnoDB 中的两种索引类型，它们的区别如下。</p> <ul><li>聚簇索引</li></ul> <p>聚簇索引（Clustered Index）一般指的是主键索引（如果存在主键索引的话），聚簇索引也被称之为聚集索引。</p> <ul><li>非聚簇索引</li></ul> <p>非聚簇索引在 InnoDB 引擎中，也叫二级索引，非聚簇索引为普通列的索引（非主键的索引）。</p> <ul><li>聚簇索引和非聚簇索引的区别</li></ul> <p>聚簇索引和非聚簇索引最大的区别在于叶子节点存储的数据不同，聚簇索引叶子节点存储的是行数据，因此通过聚簇索引可以直接找到真正的行数据；而非聚簇索引叶子节点存储的是主键信息，所以使用非聚簇索引还需要回表查询，因此我们可以得出聚簇索引和非聚簇索引的区别主要有以下几个：</p> <p>1、聚簇索引叶子节点存储的是行数据；而非聚簇索引叶子节点存储的是聚簇索引（通常是主键 ID）；</p> <p>2、聚簇索引查询效率更高，而非聚簇索引需要进行回表查询，因此性能不如聚簇索引；</p> <p>3、聚簇索引一般为主键索引，而主键一个表中只能有一个，因此聚簇索引一个表中也只能有一个，而非聚簇索引则没有数量上的限制。</p> <p>简单来说，聚簇索引查询效率高，而非聚簇索引为普通索引，它存储的是主键索引的信息，因此还需要再使用主键索引的信息进行二次查询，所以性能不如聚簇索引。</p> <h3 id="聚簇索引等于主键索引吗"><a href="#聚簇索引等于主键索引吗" class="header-anchor">#</a> 聚簇索引等于主键索引吗？</h3> <p>聚簇索引不等于主键索引。</p> <p>聚簇索引的产生过程如下：</p> <p>1、当你为一张表创建主键时，也就是定义 PRIMARY KEY 时，此时这张表的聚簇索引就是主键索引。通常情况下，我们应该为一张表设置一个主键，如果没有合适的列作为主键列，我们可以定义一个自动递增的唯一列为主键，并且在插入数据时是自动填充此列；</p> <p>2、然而，如果一张表中没有设置主键，那么 InnoDB 会使用第一个唯一索引（unique），且此唯一索引设置了非空约束（not null），我们就使用它作为聚簇索引；</p> <p>3、如果一张表既没有主键索引，又没有符合条件的唯一索引，那么 InnoDB 会生成一个名为 GEN_CLUST_INDEX 的隐藏聚簇索引，这个隐藏的索引为 6 字节的长整数类型。</p> <h3 id="唯一索引和普通索引哪个性能更好"><a href="#唯一索引和普通索引哪个性能更好" class="header-anchor">#</a> 唯一索引和普通索引哪个性能更好？</h3> <p>唯一索引和普通索引的性能对比分为以下两种情况：</p> <p>1、对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别；</p> <p>2、对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比唯一索引要多了判断操作，从而性能就比普通索引性能要低。</p> <h3 id="临时表是内存表吗"><a href="#临时表是内存表吗" class="header-anchor">#</a> 临时表是内存表吗？</h3> <p>临时表和内存表是不同的。</p> <p>1、内存表，指的是使用 Memory 引擎的表，建表语法是 create table … engine=memory。这种表的数据都保存在内存里，系统重启的时候会被清空，但是表结构还在。除了这两个特性看上去比较“奇怪”外，从其他的特征上看，它就是一个正常的表。</p> <p>2、而临时表，可以使用各种引擎类型 。如果是使用 InnoDB 引擎或者 MyISAM 引擎的临时表，写数据的时候是写到磁盘上的。</p> <h3 id="说一下事务的特性"><a href="#说一下事务的特性" class="header-anchor">#</a> 说一下事务的特性？</h3> <p>事务是一系列的数据库操作，是数据库应用的基本单位。</p> <p>在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下：</p> <p>1、原子性（Atomic），要么全部执行，要么全部不执行；</p> <p>2、一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态；</p> <p>3、隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</p> <p>4、持久性（Durability），事务提交后，其结果永久保存在数据库中。</p> <h3 id="事务有哪些隔离级别"><a href="#事务有哪些隔离级别" class="header-anchor">#</a> 事务有哪些隔离级别？</h3> <p>MySQL 中有四种事务隔离级别，分别是：</p> <p>1、read uncommited：读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读；</p> <p>2、read committed：读已提交，也叫提交读，该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读；</p> <p>3、repetable read：可重复读，MySQL 默认的事务隔离级别。可重复读可以解决“不可重复读”的问题，但还存在幻读的问题。所谓的幻读指的是，在同一事务的不同时间使用相同 SQL 查询时，会产生不同的结果。例如，一个 SELECT 被执行了两次，但是第二次返回了第一次没有返回的一行，那么这一行就是一个“幻像”行；</p> <p>4、serializable：序列化，事务最高隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。</p> <h3 id="什么是脏读"><a href="#什么是脏读" class="header-anchor">#</a> 什么是脏读？</h3> <p>脏读是指一个事务读取到了另一个事务为提交保存的数据，之后此事务进行了回滚操作，从而导致第一个事务读取了一个不存在的脏数据。</p> <h3 id="什么是不可重复读"><a href="#什么是不可重复读" class="header-anchor">#</a> 什么是不可重复读？</h3> <p>在同一个事务中，同一个查询在不同的时间得到了不同的结果。例如事务在 T1 读取到了某一行数据，在 T2 时间重新读取这一行时候，这一行的数据已经发生修改，所以再次读取时得到了一个和 T1 查询时不同的结果。</p> <h3 id="什么是幻读"><a href="#什么是幻读" class="header-anchor">#</a> 什么是幻读？</h3> <p>同一个查询在不同时间得到了不同的结果，这就是事务中的幻读问题。例如，一个 SELECT 被执行了两次，但是第二次返回了第一次没有返回的一行，那么这一行就是一个“幻像”行。</p> <h3 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="header-anchor">#</a> 不可重复读和幻读有什么区别？</h3> <p>二者的区别如下：</p> <p>1、不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）；</p> <p>2、幻读的重点在于新增或者删除：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）。</p> <h3 id="mysql-事务实现原理是什么"><a href="#mysql-事务实现原理是什么" class="header-anchor">#</a> MySQL 事务实现原理是什么？</h3> <p>以 InnoDB 的事务为例，InnoDB 可以通过多版本并发控制（MVCC，Multiversion Concurrency Control ）解决不可重复读问题，加上间隙锁（也就是并发控制）解决幻读问题。因此 InnoDB 的 RR 隔离级别其实实现了串行化级别的效果，而且保留了比较好的并发性能。事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。</p> <h3 id="mysql-如何保证数据不丢失"><a href="#mysql-如何保证数据不丢失" class="header-anchor">#</a> MySQL 如何保证数据不丢失？</h3> <p>MySQL 是通过日志，也就是 redolog 和 binlog 来保证数据不丢失的。</p> <p>1、redo log 和 binlog 保证持久化磁盘就能确保 MySQL 异常重启后恢复数据；</p> <p>2、在恢复数据时，redolog 状态为 commit 则说明 binlog 也成功，直接恢复数据；如果 redolog 是 prepare，则需要查询对应的 binlog事务是否成功，决定是回滚还是执行。</p> <h3 id="redo-log-和-binlog-区别"><a href="#redo-log-和-binlog-区别" class="header-anchor">#</a> redo log 和 binlog 区别？</h3> <p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p> <p>1、redo log 是物理日志，记录的是“在某个数据页上做了什么修改”。</p> <p>2、binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p> <p>3、redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</p> <p>4、redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</p> <h3 id="为什么需要-redo-log"><a href="#为什么需要-redo-log" class="header-anchor">#</a> 为什么需要 redo log？</h3> <p>1、redo log 主要用于 MySQL 异常重启后的一种数据恢复手段，确保了数据的一致性；</p> <p>2、其实是为了配合 MySQL 的 WAL 机制。因为 MySQL 进行更新操作，为了能够快速响应，所以采用了异步写回磁盘的技术，写入内存后就返回。但是这样，会存在 crash（宕机）后内存数据丢失的隐患，而 redo log 具备 crash safe 的能力。</p> <h3 id="binlog-可以替代-redo-log-吗"><a href="#binlog-可以替代-redo-log-吗" class="header-anchor">#</a> binlog 可以替代 redo log 吗？</h3> <p>不行。</p> <p>第一点：redo log 可确保 innoDB 判断哪些数据已经刷盘，哪些数据还没有。</p> <p>1、redo log 和 binlog 有一个很大的区别就是，一个是循环写，一个是追加写。也就是说 redo log 只会记录未刷盘的日志，已经刷入磁盘的数据都会从 redo log 这个有限大小的日志文件里删除。binlog 是追加日志，保存的是全量的日志；</p> <p>2、当数据库 crash 后，想要恢复未刷盘但已经写入 redo log 和 binlog 的数据到内存时，binlog 是无法恢复的。虽然 binlog 拥有全量的日志，但没有一个标志让 innoDB 判断哪些数据已经刷盘，哪些数据还没有；</p> <p>3、但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中抹掉，因为是循环写！数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。</p> <p>第二点：如果 redo log 写入失败，说明此次操作失败，事务也不可能提交。</p> <p>1、redo log 每次更新操作完成后，就一定会写入日志，如果写入失败，说明此次操作失败，事务也不可能提交；</p> <p>2、redo log 内部结构是基于页的，记录了这个页的字段值变化，只要crash后读取redo log进行重放，就可以恢复数据；</p> <p>这就是为什么 redo log 具有 crash-safe 的能力，而 binlog 不具备，使用使用 binlog 不能替代 redo log。</p> <h3 id="mysql-中有哪些锁"><a href="#mysql-中有哪些锁" class="header-anchor">#</a> MySQL 中有哪些锁？</h3> <p>MySQL 提供了：全局锁、行级锁、表级锁。其中 InnoDB 支持表级锁和行级锁，MyISAM 只支持表级锁。</p> <h3 id="mysql-会导致死锁吗"><a href="#mysql-会导致死锁吗" class="header-anchor">#</a> MySQL 会导致死锁吗？</h3> <p>会，比如将投资的钱拆封几份借给借款人，这时处理业务逻辑就要把若干个借款人一起锁住，它的执行 SQL 是：select * from xxx where id in (xx,xx,xx) for update；</p> <h3 id="如何解决-mysql-死锁"><a href="#如何解决-mysql-死锁" class="header-anchor">#</a> 如何解决 MySQL 死锁？</h3> <p>对待死锁常见的两种策略：</p> <p>1、通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时；</p> <p>2、发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其它事务继续执行。</p> <h3 id="如何查看死锁"><a href="#如何查看死锁" class="header-anchor">#</a> 如何查看死锁？</h3> <p>使用命令 <code>show engine innodb status</code>  查看最近的一次死锁；</p> <h3 id="如何避免死锁"><a href="#如何避免死锁" class="header-anchor">#</a> 如何避免死锁？</h3> <p>避免死锁的常见方案有：</p> <p>1、为了在单个 InnoDB 表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用 SELECT .</p> <p>2、在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁；</p> <p>3、如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会；</p> <p>4、通过 SELECT ... LOCK IN SHARE MODE 获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁；</p> <p>5、改变事务隔离级别。</p> <h3 id="innodb-默认是如何处理死锁的"><a href="#innodb-默认是如何处理死锁的" class="header-anchor">#</a> InnoDB 默认是如何处理死锁的？</h3> <p>InnoDB 默认是使用设置死锁时间来让死锁超时的策略，默认 innodb_lock_wait_timeout 设置的时长是 50s。</p> <h3 id="如何实现表锁"><a href="#如何实现表锁" class="header-anchor">#</a> 如何实现表锁？</h3> <p>MySQL 里标记锁有两种：表级锁、元数据锁（meta data lock）简称 MDL。表锁的语法是 lock tables t read/write。</p> <p>可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p> <p>对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p> <p>MDL：不需要显式使用，在访问一个表的时候会被自动加上。</p> <p>MDL 的作用：保证读写的正确性。</p> <p>在对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p> <p>读锁之间不互斥,读写锁之间，写锁之间是互斥的，用来保证变更表结构操作的安全性。</p> <p>MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。</p> <h3 id="innodb-如何实现行锁"><a href="#innodb-如何实现行锁" class="header-anchor">#</a> InnoDB 如何实现行锁？</h3> <p>行级锁是 MySQL 中粒度最小的一种锁，他能大大减少数据库操作的冲突。</p> <p>INNODB 的行级锁有共享锁（S LOCK）和排他锁（X LOCK）两种。共享锁允许事物读一行记录，不允许任何线程对该行记录进行修改。排他锁允许当前事物删除或更新一行记录，其他线程不能操作该记录。</p> <p>共享锁：SELECT ... LOCK IN SHARE MODE，MySQL 会对查询结果集中每行都添加共享锁，前提是当前线程没有对该结果集中的任何行使用排他锁，否则申请会阻塞。</p> <p>排他锁：select * from t where id=1 for update，其中 id 字段必须有索引，MySQL 会对查询结果集中每行都添加排他锁，在事物操作中，任何对记录的更新与删除操作会自动加上排他锁。前提是当前没有线程对该结果集中的任何行使用排他锁或共享锁，否则申请会阻塞。</p> <h3 id="什么是慢查询"><a href="#什么是慢查询" class="header-anchor">#</a> 什么是慢查询？</h3> <p>慢查询是 MySQL 中提供的一种慢查询日志，它用来记录在 MySQL 中响应时间超过阀值的语句，具体指运行时间超过 long_query_time 值的 SQL，则会被记录到慢查询日志中。long_query_time 的默认值为 10，意思是运行 10S 以上的语句。默认情况下，MySQL 数据库并不启动慢查询日志，需要我们手动来设置这个参数，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会给 MySQL 服务器带来一定的性能影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。</p> <p>使用 <code>mysql### show variables like '%slow_query_log%';</code>  来查询慢查询日志是否开启。</p> <h3 id="mysql-优化手段有哪些"><a href="#mysql-优化手段有哪些" class="header-anchor">#</a> MySQL 优化手段有哪些？</h3> <p>MySQL 的常见的优化手段有以下五种：</p> <ul><li>查询优化</li></ul> <p>1、避免 SELECT *，只查询需要的字段。</p> <p>2、小表驱动大表，即小的数据集驱动大的数据集，比如，当 B 表的数据集小于 A 表时，用 in 优化 exist，两表执行顺序是先查 B 表，再查 A 表，查询语句：select * from A where id in (select id from B) 。</p> <p>3、一些情况下，可以使用连接代替子查询，因为使用 join 时，MySQL 不会在内存中创建临时表。</p> <ul><li>优化索引的使用</li></ul> <p>1、尽量使用主键查询，而非其他索引，因为主键查询不会触发回表查询。</p> <p>2、不做列运算，把计算都放入各个业务系统实现</p> <p>3、查询语句尽可能简单，大语句拆小语句，减少锁时间</p> <p>4、不使用 select * 查询</p> <p>5、or 查询改写成 in 查询</p> <p>6、不用函数和触发器</p> <p>7、避免 %xx 查询</p> <p>8、少用 join 查询</p> <p>9、使用同类型比较，比如 '123' 和 '123'、123 和 123</p> <p>10、尽量避免在 where 子句中使用 != 或者 &lt;### 操作符，查询引用会放弃索引而进行全表扫描</p> <p>11、列表数据使用分页查询，每页数据量不要太大</p> <p>12、用 exists 替代 in 查询</p> <p>13、避免在索引列上使用 is null 和 is not null</p> <p>14、尽量使用主键查询</p> <p>15、避免在 where 子句中对字段进行表达式操作</p> <p>16、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</p> <ul><li>表结构设计优化</li></ul> <p>1、使用可以存下数据最小的数据类型。</p> <p>2、使用简单的数据类型，int 要比 varchar 类型在 MySQL 处理简单。</p> <p>3、尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int。</p> <p>4、尽可能使用 not null 定义字段，因为 null 占用 4 字节空间。</p> <p>5、尽量少用 text 类型，非用不可时最好考虑分表。</p> <p>6、尽量使用 timestamp，而非 datetime。</p> <p>7、单表不要有太多字段，建议在 20 个字段以内。</p> <ul><li>表拆分</li></ul> <p>当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。</p> <p>1、垂直拆分：是指数据表列的拆分，把一张列比较多的表拆分为多张表，比如，用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中，插入数据时，使用事务确保两张表的数据一致性。</p> <p>垂直拆分的原则：</p> <p>1、把不常用的字段单独放在一张表；</p> <p>2、把 text，blob 等大字段拆分出来放在附表中；</p> <p>4、经常组合查询的列放在一张表中。</p> <p>2、水平拆分：指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。</p> <p>通常情况下，我们使用取模的方式来进行表的拆分，比如，一张有 400W 的用户表 users，为提高其查询效率我们把其分成 4 张表 users1，users2，users3，users4，然后通过用户 ID 取模的方法，同时查询、更新、删除也是通过取模的方法来操作。</p> <ul><li>读写分离</li></ul> <p>一般情况下对数据库而言都是“读多写少”，换言之，数据库的压力多数是因为大量的读取数据的操作造成的，我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。</p> <h3 id="mysql-常见读写分离方案有哪些"><a href="#mysql-常见读写分离方案有哪些" class="header-anchor">#</a> MySQL 常见读写分离方案有哪些？</h3> <p>MySQL 常见的读写分离方案，可以从应用层解决或使用中间件来解决。</p> <ul><li>应用层解决方案</li></ul> <p>可以通过应用层对数据源做路由来实现读写分离，比如，使用 SpringMVC + MyBatis，可以将 SQL 路由交给 Spring，通过 AOP 或者 Annotation 由代码显示的控制数据源。</p> <p>优点：路由策略的扩展性和可控性较强。</p> <p>缺点：需要在 Spring 中添加耦合控制代码。</p> <ul><li>中间件解决方案</li></ul> <p>通过 MySQL 的中间件做主从集群，比如：Mysql Proxy、Amoeba、Atlas 等中间件都能符合需求。</p> <p>优点：与应用层解耦。</p> <p>缺点：增加一个服务维护的风险点，性能及稳定性待测试，需要支持代码强制主从和事务。</p> <h3 id="表的优化策略有哪些"><a href="#表的优化策略有哪些" class="header-anchor">#</a> 表的优化策略有哪些？</h3> <p>常见的大表优化策略如下：</p> <p>1、读写分离，主库负责写，从库负责读。</p> <p>2、垂直分区，根据数据属性单独拆表甚至单独拆库。</p> <p>3、水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。</p> <h3 id="数据被误删了怎么恢复"><a href="#数据被误删了怎么恢复" class="header-anchor">#</a> 数据被误删了怎么恢复？</h3> <p>如果发生了数据删除的操作，它对应的场景和恢复方案如下：</p> <p>1、如果是 DML 误操作语句造成数据不完整或者丢失的情况：可以通过 flashback 或美团的 myflash 来恢复。它是先解析 binlog event，然后在进行反转，把 delete 反转为 insert，insert 反转为 delete 进行恢复的。所以必须设置 binlog_format=row 和 binlog_row_image=full，切记恢复数据的时候，应该先恢复到临时的实例，然后在恢复回主库上；</p> <p>2、DDL语句误操作（truncate 和 drop）：由于 DDL 语句不管 binlog_format 是 row 还是 statement ，在 binlog 里都只记录语句，不记录 image 所以恢复起来相对要麻烦得多。只能通过全量备份+应用 binlog 的方式来恢复数据。一旦数据量比较大，那么恢复时间就特别长；</p> <p>3、rm 删除：使用备份跨机房，所以最好是跨城市保存。</p> <h3 id="drop、truncate-和-delete-有什么区别"><a href="#drop、truncate-和-delete-有什么区别" class="header-anchor">#</a> drop、truncate 和 delete 有什么区别？</h3> <p>truncate、drop 和 delete 的区别主要有以下 6 点：</p> <p>1、执行速度：drop ### truncate ### detele；</p> <p>2、delete 和 truncate 只删除表数据，而 drop 会删除表数据和表结构以及表的索引、约束和触发器；</p> <p>3、delete 可以加 where 条件实现部分数据删除，而 truncate 和 drop 不能加 where 条件是整体删除；</p> <p>4、truncate 和 drop 是立即执行，且不能恢复；而 delete 会走事务，可以撤回和恢复；</p> <p>5、truncate 会重置自增列为 1，而 delete 不会重置自增列；</p> <p>6、truncate 和 drop 是 DDL 语句，而 delete 是 DML 语句。</p> <h3 id="如何防止数据被误删"><a href="#如何防止数据被误删" class="header-anchor">#</a> 如何防止数据被误删？</h3> <p>防止误删，最有效的方法是做好预防，预防的话大概是通过这几个点：</p> <p>1、权限控制与分配(数据库和服务器权限)；</p> <p>2、制作操作规范；</p> <p>3、定期给开发进行培训；</p> <p>4、搭建延迟备库；</p> <p>5、做好 SQL 审计：只要是对线上数据有更改操作的语句(DML和DDL)都需要进行审核；</p> <p>6、做好备份：备份的话又分为两个点：</p> <p>7、如果数据量比较大，用物理备份 xtrabackup，定期对数据库进行全量备份，也可以做增量备份；</p> <p>8、如果数据量较少，用 mysqldump 或者 mysqldumper，再利用 binlog 来恢复或者搭建主从的方式来恢复数据。定期备份 binlog 文件也是很有必要的。</p> <h3 id="mybatis-有什么优缺点"><a href="#mybatis-有什么优缺点" class="header-anchor">#</a> MyBatis 有什么优缺点？</h3> <p>MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 去除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p> <p>MyBatis 优缺点如下：</p> <ol><li>基于 SQL 语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，解除 sql 与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态 SQL 语句，并可重用；</li> <li>与 JDBC 相比，减少了 50% 以上的代码量，消除了 JDBC 大量冗余的代码，不需要手动开关连接；</li> <li>很好的与各种数据库兼容（因为 MyBatis 使用 JDBC 来连接数据库，所以只要 JDBC 支持的数据库 MyBatis 都支持）；</li> <li>能够与 Spring 很好的集成；</li> <li>提供映射标签，支持对象与数据库的 ORM 字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li></ol> <p>缺点如下：</p> <ol><li>SQL 语句依赖于数据库，数据库移植性差；</li> <li>SQL 语句编写工作量大，尤其在表、字段比较多的情况下。</li></ol> <p>总体来说，MyBatis 是一个非常不错的持久层解决方案，它专注于 SQL 本身，非常灵活，适用于需求变化较多的互联网项目，也是当前国内主流的 ORM 框架。</p> <h3 id="说说-mybatis-执行流程"><a href="#说说-mybatis-执行流程" class="header-anchor">#</a> 说说 MyBatis 执行流程？</h3> <p>MyBatis 执行流程如下：</p> <ol><li>创建 SqlSessionFactory；</li> <li>通过 SqlSessionFactory 创建 SqlSession；</li> <li>通过 SqlSession 执行数据库操作；</li> <li>调用 session.commit() 提交事务；</li> <li>调用 session.close() 关闭会话。</li></ol> <h3 id="mybatis-和-hibernate-有什么不同"><a href="#mybatis-和-hibernate-有什么不同" class="header-anchor">#</a> MyBatis 和 Hibernate 有什么不同？</h3> <p>MyBatis 和 Hibernate 都是非常优秀的 ORM 框架，它们的区别如下：</p> <ol><li>灵活性：MyBatis 更加灵活，自己可以写 SQL 语句，使用起来比较方便；</li> <li>可移植性：MyBatis 有很多自己写的 SQL，因为每个数据库的 SQL 可以不相同，所以可移植性比较差；</li> <li>开发效率：Hibernate 对 SQL 语句做了封装，让开发者可以直接使用，因此开发效率更高；</li> <li>学习和使用门槛：MyBatis 入门比较简单，使用门槛也更低。</li></ol> <h3 id="和-有什么区别"><a href="#和-有什么区别" class="header-anchor">#</a> ${} 和 #{} 有什么区别？</h3> <p>${} 和 #{} 都是 MyBatis 中用来替换参数的。</p> <p>${} 是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如 ${myorder} 会被静态替换为 desc。#{} 是 sql 的参数占位符，MyBatis 会将 sql 中的 #{} 替换为 ? 号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的 ? 号占位符设置参数值。</p> <p>它们二者的区别主要体现在：</p> <ol><li>功能不同：${} 是直接替换，而 #{} 是预处理；</li> <li>使用场景不同：普通参数使用 #{}，如果传递的是 SQL 命令或 SQL 关键字，需要使用 ${}，但在使用前一定要做好安全验证；</li> <li>安全性不同：使用 ${} 存在安全问题，如 SQL 注入，而 #{} 则不存在安全问题。</li></ol> <h3 id="什么是-sql-注入"><a href="#什么是-sql-注入" class="header-anchor">#</a> 什么是 SQL 注入？</h3> <p>SQL 注入即是指应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在应用程序中事先定义好的查询语句的结尾上添加额外的 SQL 语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</p> <h3 id="如何解决实体类属性和表中字段不一致的问题"><a href="#如何解决实体类属性和表中字段不一致的问题" class="header-anchor">#</a> 如何解决实体类属性和表中字段不一致的问题？</h3> <p>实体类属性名和表中字段名不一致可以使用以下方式解决：</p> <ol><li>指定别名：在 SQL 中指定别名，别名等于实体类中的属性名即可；</li> <li>结果字典映射：使用 &lt;resultMap### 来映射字段名和实体类属性名的一一对应关系。</li></ol> <p>具体实现如下。</p> <p><strong>① 指定别名</strong></p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;select id=&quot;getUser&quot; resultetype=&quot;com.demo.model.userinfo&quot;###
  select id,username as name from userinfo 
&lt;/select###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>② 结果字典映射</strong></p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;select id=&quot;getUser&quot; resultMap=&quot;userMap&quot;###
    select * from userinfo
&lt;/select###

&lt;resultMap id=&quot;userMap&quot; type=&quot;com.demo.model.userinfo&quot;###
    &lt;!– 用id属性来映射主键字段 –###
    &lt;id property=&quot;id&quot; column=&quot;user_id&quot;###
    &lt;!–- 用result属性来映射非主键字段，property为实体类属性名，column为数据表中的属性 -–###
    &lt;result property=&quot;name&quot; column=&quot;username&quot; /###
&lt;/reslutMap###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="mybatis-中如何实现分页"><a href="#mybatis-中如何实现分页" class="header-anchor">#</a> MyBatis 中如何实现分页？</h3> <p>MyBatis 常见的分页方式有以下两种：</p> <ol><li>逻辑分页，使用 MyBatis 自带的 RowBounds 进行分页，它是一次性查询很多数据，然后在数据中再进行检索；</li> <li>物理分页，自己手写 SQL 分页或使用分页插件 PageHelper，去数据库查询指定条数的分页数据形式。</li></ol> <h3 id="rowbounds-是一次性查询全部结果吗"><a href="#rowbounds-是一次性查询全部结果吗" class="header-anchor">#</a> RowBounds 是一次性查询全部结果吗？</h3> <p>RowBounds 表面是在“所有”数据中检索数据，其实并非是一次性查询出所有数据。因为 MyBatis 是对 JDBC 的封装，在 JDBC 驱动中有一个 Fetch Size 的配置，它规定了每次最多从数据库查询多少条数据，假如你要查询更多数据，它会在执行 next() 的时候，去查询更多的数据。</p> <p>就好比你去自动取款机取 10000 元，但取款机每次最多能取 2500 元，要取 4 次才能把钱取完。对于 JDBC 来说也是一样，这样做的好处是可以有效的防止内存溢出。</p> <h3 id="hashmap-和-hashtable-可以作为查询结果吗"><a href="#hashmap-和-hashtable-可以作为查询结果吗" class="header-anchor">#</a> HashMap 和 Hashtable 可以作为查询结果吗？</h3> <p>HashMap 和 Hashtable 不能直接作为查询结果，因为使用 HashMap 或 Hashtable 作为查询结果集直接输出，会导致值类型不可控，给调用人员造成困扰，给系统带来更多不稳定的因素。</p> <h3 id="说一说动态-sql"><a href="#说一说动态-sql" class="header-anchor">#</a> 说一说动态 SQL？</h3> <p>动态 SQL 是指可以根据不同的参数信息来动态拼接的不确定的 SQL 叫做动态 SQL，MyBatis 动态 SQL 的主要元素有：if、choose/when/otherwise、trim、where、set、foreach 等。</p> <p>以 if 标签的使用为例：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;select id=&quot;findUser&quot; parameterType=&quot;com.interview.entity.User&quot; resultType=&quot;com.interview.entity.User&quot;###
      select * from t_user where

      &lt;if test=&quot;id!=null&quot;###
        id = #{id}
      &lt;/if###

      &lt;if test=&quot;username!=null&quot;###
        and username = #{username}
      &lt;/if###

      &lt;if test=&quot;password!=null&quot;###
        and password = #{password}
      &lt;/if###
&lt;/select###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="说一说-mybatis-工作原理"><a href="#说一说-mybatis-工作原理" class="header-anchor">#</a> 说一说 MyBatis 工作原理？</h3> <p>MyBatis 工作原理如下：</p> <ol><li>读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息；</li> <li>加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表；</li> <li>构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory；</li> <li>创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法；</li> <li>Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护；</li> <li>MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息；</li> <li>输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程；</li> <li>输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</li></ol> <h3 id="说一下-mybatis-延迟加载机制"><a href="#说一下-mybatis-延迟加载机制" class="header-anchor">#</a> 说一下 MyBatis 延迟加载机制？</h3> <p>MyBatis 中的延迟加载，也称为懒加载，是指在进行表的关联查询时，按照设置延迟规则推迟对关联对象的 select 查询。例如在进行一对多查询的时候，只查询出一方，当程序中需要多方的数据时，mybatis 再发出 sql 语句进行查询，这样子延迟加载就可以的减少数据库压力。MyBatis 的延迟加载只是对关联对象的查询有迟延设置，对于主加载对象都是直接执行查询语句的。</p> <h3 id="如何设置-mybatis-延迟加载"><a href="#如何设置-mybatis-延迟加载" class="header-anchor">#</a> 如何设置 MyBatis 延迟加载？</h3> <p>在 mybatis-config.xml 设置即可打开延迟缓存功能，配置文件如下：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;configuration###
    &lt;settings###
        &lt;!-- 开启延迟加载 --###
        &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/###
    &lt;/settings###
&lt;/configuration###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="说一下-mybatis-的缓存机制"><a href="#说一下-mybatis-的缓存机制" class="header-anchor">#</a> 说一下 MyBatis 的缓存机制？</h3> <p>MyBatis 中有两级缓存，具体缓存如下：</p> <ol><li>一级缓存是 SqlSession 级别的，是 MyBatis 自带的缓存功能，并且无法关闭，因此当有两个 SqlSession 访问相同的 SQL 时，一级缓存也不会生效，需要查询两次数据库；</li> <li>二级缓存是 Mapper 级别的，只要是同一个 Mapper，无论使用多少个 SqlSession 来操作，数据都是共享的，多个不同的 SqlSession 可以共用二级缓存，MyBatis 二级缓存默认是关闭的，需要使用时可手动开启，二级缓存也可以使用第三方的缓存，比如，使用 Ehcache 作为二级缓存。</li></ol> <p>手动开启二级缓存，配置如下：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;configuration###
    &lt;settings###
        &lt;!-- 开启二级缓存 --###
        &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/###
    &lt;/settings###
&lt;/configuration###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="mybatis-中有哪些设计模式"><a href="#mybatis-中有哪些设计模式" class="header-anchor">#</a> MyBatis 中有哪些设计模式？</h3> <p>MyBatis 源码中的几个主要设计模式，即工厂模式、建造者模式、单例模式、适配器模式、代理模式、模板方法模式等，具体内容如下。</p> <p><strong>① 工厂模式</strong></p> <p>工厂模式想必都比较熟悉，它是 Java 中最常用的设计模式之一。工厂模式就是提供一个工厂类，当有客户端需要调用的时候，只调用这个工厂类就可以得到自己想要的结果，从而无需关注某类的具体实现过程。这就好比你去餐馆吃饭，可以直接点菜，而不用考虑厨师是怎么做的。</p> <p>工厂模式在 MyBatis 中的典型代表是 SqlSessionFactory。SqlSession 是 MyBatis 中的重要 Java 接口，可以通过该接口来执行 SQL 命令、获取映射器示例和管理事务，而 SqlSessionFactory 正是用来产生 SqlSession 对象的，所以它在 MyBatis 中是比较核心的接口之一。</p> <p><strong>② 建造者模式</strong></p> <p>建造者模式指的是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也就是说建造者模式是通过多个模块一步步实现了对象的构建，相同的构建过程可以创建不同的产品。</p> <p>例如，组装电脑，最终的产品就是一台主机，然而不同的人对它的要求是不同的，比如设计人员需要显卡配置高的；而影片爱好者则需要硬盘足够大的（能把视频都保存起来），但对于显卡却没有太大的要求，我们的装机人员根据每个人不同的要求，组装相应电脑的过程就是建造者模式。</p> <p>建造者模式在 MyBatis 中的典型代表是 SqlSessionFactoryBuilder。普通的对象都是通过 new 关键字直接创建的，但是如果创建对象需要的构造参数很多，且不能保证每个参数都是正确的或者不能一次性得到构建所需的所有参数，那么就需要将构建逻辑从对象本身抽离出来，让对象只关注功能，把构建交给构建类，这样可以简化对象的构建，也可以达到分步构建对象的目的，而 SqlSessionFactoryBuilder 的构建过程正是如此。</p> <p><strong>③ 单例模式</strong></p> <p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，此模式保证某个类在运行期间，只有一个实例对外提供服务，而这个类被称为单例类。</p> <p>单例模式也比较好理解，比如一个人一生当中只能有一个真实的身份证号，每个收费站的窗口都只能一辆车子一辆车子的经过，类似的场景都是属于单例模式。单例模式在 MyBatis 中的典型代表是 ErrorContext。</p> <p>ErrorContext 是线程级别的的单例，每个线程中有一个此对象的单例，用于记录该线程的执行环境的错误信息。</p> <p><strong>④ 适配器模式</strong></p> <p>适配器模式是指将一个不兼容的接口转换成另一个可以兼容的接口，这样就可以使那些不兼容的类可以一起工作。</p> <p>例如，最早之前我们用的耳机都是圆形的，而现在大多数的耳机和电源都统一成了方形的 typec 接口，那之前的圆形耳机就不能使用了，只能买一个适配器把圆形接口转化成方形的。</p> <p>而这个转换头就相当于程序中的适配器模式，适配器模式在 MyBatis 中的典型代表是 Log。</p> <p>MyBatis 中的日志模块适配了以下多种日志类型：</p> <ol><li>SLF4J</li> <li>Apache Commons Logging</li> <li>Log4j 2</li> <li>Log4j</li> <li>JDK logging</li></ol> <p><strong>⑤ 代理模式</strong></p> <p>代理模式指的是给某一个对象提供一个代理对象，并由代理对象控制原对象的调用。</p> <p>代理模式在生活中也比较常见，比如我们常见的超市、小卖店其实都是一个个“代理”，他们的最上游是一个个生产厂家，他们这些代理负责把厂家生产出来的产品卖出去。</p> <p>代理模式在 MyBatis 中的典型代表是 MapperProxyFactory。</p> <p>MapperProxyFactory 的 newInstance() 方法就是生成一个具体的代理来实现某个功能。</p> <p><strong>⑥ 模板方法模式</strong></p> <p>模板方法模式是最常用的设计模式之一，它是指定义一个操作算法的骨架，而将一些步骤的实现延迟到子类中去实现，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。此模式是基于继承的思想实现代码复用的。</p> <p>例如，我们喝茶的一般步骤都是这样的：</p> <ol><li>把热水烧开</li> <li>把茶叶放入壶中</li> <li>等待一分钟左右</li> <li>把茶倒入杯子中</li> <li>喝茶</li></ol> <p>整个过程都是固定的，唯一变的就是泡入茶叶种类的不同，比如今天喝的是绿茶，明天可能喝的是红茶，那么我们就可以把流程定义为一个模板，而把茶叶的种类延伸到子类中去实现，这就是模板方法的实现思路。</p> <p>模板方法在 MyBatis 中的典型代表是 BaseExecutor，在 MyBatis 中 BaseExecutor 实现了大部分SQL 执行的逻辑。</p> <p><strong>⑦ 装饰器模式</strong></p> <p>装饰器模式允许向一个现有的对象添加新的功能，同时又不改变其结构，这种类型的设计模式属于结构型模式，它是作为现有类的一个包装。</p> <p>装饰器模式在生活中很常见，比如装修房子，我们在不改变房子结构的同时，给房子添加了很多的点缀；比如安装了天然气报警器，增加了热水器等附加的功能都属于装饰器模式。</p> <p>装饰器模式在 MyBatis 中的典型代表是 Cache。</p> <p>Cache 除了有数据存储和缓存的基本功能外（由 PerpetualCache 永久缓存实现），还有其他附加的 Cache 类，比如先进先出的 FifoCache、最近最少使用的 LruCache、防止多线程并发访问的 SynchronizedCache 等众多附加功能的缓存类。</p> <h3 id="介绍一下-spring"><a href="#介绍一下-spring" class="header-anchor">#</a> 介绍一下 Spring</h3> <p>Spring 是一款顶级开源框架，它是包含了众多工具方法的 IoC 容器。</p> <p>Spring 包含了很多模块，比如 spring-core、spring-beans、spring-aop、spring-context、spring-expression、spring-test 等，使用 Spring 可以帮我们快速的开发 Java 程序。</p> <h3 id="spring-有什么优点"><a href="#spring-有什么优点" class="header-anchor">#</a> Spring 有什么优点</h3> <p>Spring 优点如下：</p> <ol><li>开源免费的热门框架，稳定性高、解决问题成本低；</li> <li>方便集成各种优秀的框架；</li> <li>降低了代码耦合性，通过 Spring 提供的 IoC 容器，我们可以将对象之间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合；</li> <li>方便程序测试，在 Spring 里，测试变得非常简单，例如：Spring 对 Junit 的支持，可以通过注解方便的测试 Spring 程序；</li> <li>降低 Java EE API 的使用难度，Spring 对很多难用的 Java EE API（如 JDBC、JavaMail、远程调用等）提供了一层封装，通过 Spring 的简易封装，让这些 Java EE API 的使用难度大为降低。</li></ol> <h3 id="什么是-ioc"><a href="#什么是-ioc" class="header-anchor">#</a> 什么是 IoC？</h3> <p>IoC 是 Inversion of Control 的缩写，翻译成中文是“控制反转”的意思，它不是一个具体的技术，而是一个实现对象解耦的思想。</p> <p>控制反转的意思是将依赖对象生命周期的控制权进行反转，传统开发是当前类控制依赖对象的生命周期的，现在交给其他人（Spring），这就是控制（权）反转。</p> <h3 id="ioc-有什么优点"><a href="#ioc-有什么优点" class="header-anchor">#</a> IoC 有什么优点？</h3> <p>IoC 的优点有以下几个：</p> <ol><li>使用更方便，拿来即用，无需显式的创建和销毁的过程；</li> <li>可以很容易提供众多服务，比如事务管理、消息服务等；</li> <li>提供了单例模式的支持；</li> <li>提供了 AOP 抽象，利用它很容易实现权限拦截、运行期监控等功能；</li> <li>更符合面向对象的设计法则；</li> <li>低侵入式设计，代码的污染极低，降低了业务对象替换的复杂性。</li></ol> <h3 id="ioc-是如何实现解耦的"><a href="#ioc-是如何实现解耦的" class="header-anchor">#</a> IoC 是如何实现解耦的？</h3> <p>举个例子，比如 A 对象中需要依赖 B 对象，需要调用  B 中的某个方法，我们通常的实现方法是这样的：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用 B 类中的 init 方法</span>
        <span class="token class-name">B</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        b<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;你好，世界。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>然而此时对象 A 和对象 B 是存在耦合的，因为一旦修改了 B 对象构造方法的参数之后，那么 A 对象里面的写法也要跟着改变，比如当我们将构造方法改为以下代码时：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;姓名：&quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;你好，世界。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>此时构造方法已经从原本无参构造方法变成了有参的构造方法，这里不考虑构造方法重载的情况，因为实际业务中，很可能是 B 类的构造方法写错了，忘记加参数了，于是后面又补充了一个参数，此时是不需要对构造方法进行重载的，那么此时，之前对象 A 里面的调用就会报错。</p> <p>这就是开发中经常遇到的一个问题，那怎么解决呢？</p> <p>我们可以通过将对象传递而并 new 对象的方式来解决，如下代码所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先定义一个需要依赖的 B 对象</span>
    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>
    <span class="token comment">// 通过构造方法实现赋值（初始化）</span>
    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用 B 类中的 init 方法</span>
        b<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;姓名：&quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;你好，世界。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>这样改造之后，无论构造方法怎么修改，即使需要加更多的参数，而调用它的 A 类都无需做任何修改，这样就实现了对象的解耦。</p> <h3 id="什么是-di"><a href="#什么是-di" class="header-anchor">#</a> 什么是 DI？</h3> <p>DI 是 Dependency Injection 的缩写，翻译成中文是“依赖注入”的意思。依赖注入不是一种设计实现，而是一种具体的技术，它是在 IoC 容器运行期间，动态地将某个依赖对象注入到当前对象的技术就叫做 DI（依赖注入）。</p> <p>比如 A 对象需要依赖 B 对象，那么在 A 运行时，动态的将依赖对象 B 注入到当前类中，而非通过直接 new 的方式获取 B 对象的方式，就是依赖注入。</p> <h3 id="ioc-和-di-有什么区别"><a href="#ioc-和-di-有什么区别" class="header-anchor">#</a> IoC 和 DI 有什么区别？</h3> <p>IoC 和 DI 虽然定义不同，但它们所做的事情都是一样的，都是用来实现对象解耦的，而二者又有所不同：IoC 是一种设计思想，而 DI 是一种具体的实现技术。</p> <h3 id="除了-ioc-和-di-spring-还有什么重要的功能"><a href="#除了-ioc-和-di-spring-还有什么重要的功能" class="header-anchor">#</a> 除了 IoC 和 DI，Spring 还有什么重要的功能？</h3> <p>除了 IoC 和 DI，AOP 也是 Spring 中的重要功能。</p> <h3 id="说一下-aop"><a href="#说一下-aop" class="header-anchor">#</a> 说一下 AOP？</h3> <p>AOP（Aspect-OrientedProgramming，面向切面编程）可以说是 OOP（Object-Oriented Programing，面向对象编程）的补充和完善，OOP 引入封装、继承和多态性等概念来建立一种公共对象处理的能力，当我们需要处理公共行为的时候，OOP 就会显得无能为力，而 AOP 的出现正好解决了这个问题。比如统一的日志处理模块、授权验证模块等都可以使用 AOP 很轻松的处理。</p> <h3 id="aop-有什么优点-常见使用场景有哪些"><a href="#aop-有什么优点-常见使用场景有哪些" class="header-anchor">#</a> AOP 有什么优点？常见使用场景有哪些？</h3> <p><strong>AOP 优点：</strong></p> <ol><li>集中处理某一类问题，方便维护；</li> <li>逻辑更加清晰；</li> <li>降低模块间的耦合度。</li></ol> <p><strong>AOP 常见的使用场景：</strong></p> <ol><li>用户登录和鉴权</li> <li>统一日志记录</li> <li>统一方法执行时间统计</li> <li>统一的返回格式设置</li> <li>统一的异常处理</li> <li>事务的开启和提交等</li></ol> <h3 id="aop-是如何组成的"><a href="#aop-是如何组成的" class="header-anchor">#</a> AOP 是如何组成的？</h3> <p>AOP 是由：切面（Aspect）、切点（Pointcut）、连接点（Join Point）和通知（Advice）组成的，它们的具体含义如下。</p> <p><strong>① 切面（Aspect）</strong></p> <p>切面（Aspect）由切点（Pointcut）和通知（Advice）组成，它既包含了横切逻辑的定义，也包括了连接点的定义。</p> <p>简单来说，切面就是当前 AOP 功能的类型，比如当前 AOP 是用户登录和鉴权的功能，那么它就是一个切面。</p> <p><strong>② 切点（Pointcut）</strong></p> <p>切点 Pointcut：它的作用就是提供一组规则（使用 AspectJ pointcut expression language 来描述）用来匹配连接点的。</p> <p>简单来说，切点就是设置拦截规则的，满足规则的方法将会被拦截。</p> <p>③ <strong>连接点（Join Point）</strong></p> <p>应用执行过程中能够插入切面的一个点，这个点可以是方法调用时，抛出异常时，甚至修改字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p> <p>简单来说，所有可以触发切点拦截规则的功能都是连接点。比如所有要登录才能访问的控制器（方法），它们都属于连接点。</p> <p><strong>④ 通知（Advice）</strong></p> <p>切面也是有目标的 ——它必须完成的工作。在 AOP 术语中，切面的工作被称之为通知。</p> <p>简单来说，当控制器（方法）被拦截之后，触发执行的具体方法就是通知。</p> <p>小结：切面定义了 AOP 的功能，切点提供了具体的拦截规则，通知决定了具体的执行方法，而连接点就是用来触发 AOP 的这些功能的，它们共同组成了 AOP。</p> <h3 id="spring-aop-有几种通知-advice"><a href="#spring-aop-有几种通知-advice" class="header-anchor">#</a> Spring AOP 有几种通知（Advice）？</h3> <p>Spring AOP 中有 5 种通知类型：</p> <ol><li><strong>前置通知</strong>使用 @Before 实现：通知方法会在目标方法调用之前执行；</li> <li><strong>后置通知</strong>使用 @After 实现：通知方法会在目标方法返回或者抛出异常后调用；</li> <li><strong>返回通知</strong>使用 @AfterReturning 实现：通知方法会在目标方法返回后调用；</li> <li><strong>抛出异常通知</strong>使用 @AfterThrowing 实现：通知方法会在目标方法抛出异常后调用；</li> <li><strong>环绕通知</strong>使用 @Around 实现：通知包裹了被通知的方法，在被通知的方法通知之前和调用之后执行自定义的行为。</li></ol> <h3 id="如何实现-spring-aop"><a href="#如何实现-spring-aop" class="header-anchor">#</a> 如何实现 Spring AOP？</h3> <p>Spring AOP 功能的实现，分为以下 4 步：</p> <ol><li>添加 Spring AOP 框架支持；</li> <li>添加切面；</li> <li>添加切点；</li> <li>添加通知。</li></ol> <p>具体实现代码如下。</p> <p><strong>① 添加 Spring AOP 框架</strong></p> <p>如果是 Maven 类型的（Spring Boot）项目，在 pom.xml 中添加如下信息：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop --###
&lt;dependency###
      &lt;groupId###org.springframework.boot&lt;/groupId###
      &lt;artifactId###spring-boot-starter-aop&lt;/artifactId###
&lt;/dependency###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>② 添加切面</strong></p> <p>创建一个类，在类上添加 @Aspect 注解，表明当前类为切面类：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">ProceedingJoinPoint</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span> <span class="token comment">// 表明此类为一个切面</span>
<span class="token annotation punctuation">@Component</span> <span class="token comment">// 此注解也不能少</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAspect</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><strong>③ 添加切点</strong></p> <p>在切面类中添加切点方法，并配置拦截规则：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">ProceedingJoinPoint</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span> <span class="token comment">// 表明此类为一个切面</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAspect</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义切点，并配置拦截规则（拦截 UserController 中所有的方法）</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* com.example.demo.controller.UserController.*(..))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p><strong>④ 添加通知</strong></p> <p>之后添加通知，也就是拦截之后具体执行的业务方法，这里提供 5 种通知的简单实现：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">ProceedingJoinPoint</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Aspect</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserAspect</span> <span class="token punctuation">{</span>
    <span class="token comment">// 定义切点方法</span>
    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">&quot;execution(* com.example.demo.controller.UserController.*(..))&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>
    
    <span class="token comment">// 通知类型1：前置通知</span>
    <span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">&quot;pointcut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doBefore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;执行 Before 方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 通知类型2：后置通知</span>
    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">&quot;pointcut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;执行 After 方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 通知类型3：return 之前通知</span>
    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span><span class="token string">&quot;pointcut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfterReturning</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;执行 AfterReturning 方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 通知类型4：抛出异常之前通知</span>
    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span><span class="token string">&quot;pointcut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAfterThrowing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;执行 doAfterThrowing 方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 通知类型4：添加环绕通知</span>
    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">&quot;pointcut()&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">doAround</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> joinPoint<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Around 方法开始执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 执行拦截方法</span>
           obj <span class="token operator">=</span> joinPoint<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> throwable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            throwable<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Around 方法结束执行&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><h3 id="说一下-spring-aop-实现原理"><a href="#说一下-spring-aop-实现原理" class="header-anchor">#</a> 说一下 Spring AOP 实现原理？</h3> <p>Spring AOP 是构建在动态代理的基础上实现的，如果我们为 Spring 的某个 bean 配置了切面，那么 Spring 在创建这个 bean 的时候，实际上创建的是这个 bean 的一个代理对象，我们后续对 bean 中方法的调用，实际上调用的是代理类重写的代理方法。</p> <p>Spring AOP 支持两种动态代理：JDK Proxy 和 CGLIB 动态代理。默认情况下，实现了接口的类，使用 AOP 会基于 JDK 生成代理类，没有实现接口的类，会基于 CGLIB 生成代理类。</p> <h3 id="如何将-bean-存储到-spring"><a href="#如何将-bean-存储到-spring" class="header-anchor">#</a> 如何将 Bean 存储到 Spring？</h3> <p>将 Bean 存储到 Spring 中有两种方式：</p> <ol><li>通过 xml 的方式将 Bean 注入到 Spring 中；</li> <li>通过注解的方式将 Bean 注入到 Spring 中。</li></ol> <p><strong>① xml 方式注入 Bean</strong></p> <p>在 Spring 的配置文件中，插入 &lt;bean### 标签，如下所示：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?###
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;###
    &lt;bean id=&quot;user&quot; class=&quot;com.demo.User&quot;###&lt;/bean###
&lt;/beans###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>其中：id 为 bean 的标识（名称），读取时使用，class 为 bean 的完整包名 + 类名。</p> <p><strong>② 注解方式注入 Bean</strong></p> <p>注解方式注入 Bean 有分为两种类型：</p> <ol><li>通过类注解注入 Bean，如：@Controller、@Service、@Repository、@Component、@Configuration 等；</li> <li>通过方法注解注入 Bean，如：@Bean。</li></ol> <p>类注解注入的实现如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span> <span class="token comment">// 将对象存储到 Spring 中</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHi</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hi,&quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>方法注解注入的实现如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserBeans</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="说一下-bean-的命名规则"><a href="#说一下-bean-的命名规则" class="header-anchor">#</a> 说一下 Bean 的命名规则？</h3> <p>使用注解注入 Bean 时，它的命名规则分为以下两种情况：</p> <ol><li>类注解命名规则：注入类的首字母和第二个字母是否为大写，如果都为大写，那么 Bean 的名称为原类名，否则就是类名首字母小写。如 UClass 的 Bean 名称为 UClass，而 UserClass 的 Bean 命名成 userClass；</li> <li>方法注解 @Bean 命名规则：如果没有显示指定 Bean 的名称，那么它的名字就为方法名。</li></ol> <h3 id="bean-名称冲突该如何处理"><a href="#bean-名称冲突该如何处理" class="header-anchor">#</a> @Bean 名称冲突该如何处理？</h3> <p>默认情况下 @Bean 的名称为方法名，但如果方法名重复的话，就会导致读取 Bean 时，只能读取到某一个对象，这个时候想要读取到另一个对象时，就要显示的指定 Bean 名称了，Bean 名称的设置如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserBeans</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">&quot;user1&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">&quot;Java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>上述代码就将 Bean 的名称从默认的 user，重命名为 user1 了。</p> <h3 id="获取-spring-容器有几种方法"><a href="#获取-spring-容器有几种方法" class="header-anchor">#</a> 获取 Spring 容器有几种方法？</h3> <p>获取 Spring 容器有两种常用的方法：</p> <ol><li>使用 ApplicationContext 来获取 Spring 容器；</li> <li>使用 BeanFactory 来获取容器。</li></ol> <p>具体实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 1.ApplicationContext 获取 Spring 容器</span>
<span class="token class-name">ApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathXmlApplicationContext</span><span class="token punctuation">(</span><span class="token string">&quot;spring-config.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 2.BeanFactory 获取 Spring 容器</span>
<span class="token class-name">BeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XmlBeanFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">&quot;spring-config.xml&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="applicationcontext-和-beanfactory-有什么区别"><a href="#applicationcontext-和-beanfactory-有什么区别" class="header-anchor">#</a> ApplicationContext 和 BeanFactory 有什么区别？</h3> <p>它们都可以用来获取 Spring 容器，它们的区别如下：</p> <ol><li>继承关系和功能：Spring 容器有两个顶级的接口：BeanFactory 和 ApplicationContext。其中 BeanFactory 提供了基础的访问容器的能力，而 ApplicationContext 属于 BeanFactory 的子类，它除了继承了 BeanFactory 的所有功能之外，它还拥有独特的特性，还添加了对国际化支持、资源访问支持、以及事件传播等方面的支持。</li> <li>性能：ApplicationContext 是一次性加载并初始化所有的 Bean 对象，而 BeanFactory 是需要那个才去加载那个，因此更加轻量。</li></ol> <h3 id="bean-注入有几种方式"><a href="#bean-注入有几种方式" class="header-anchor">#</a> Bean 注入有几种方式？</h3> <p>Spring 中对象注入的方法有 3 种：</p> <ol><li>属性注入（Field Injection）</li> <li>Setter 注入（Setter Injection）</li> <li>构造方法注入（Constructor Injection）</li></ol> <p>接下来，我们分别来看。</p> <p><strong>① 属性注入</strong></p> <p>属性注入是我们最熟悉，也是日常开发中使用最多的一种注入方式，它的实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>
    <span class="token comment">// 属性对象</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/add&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">UserInfo</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>属性注入最大的优点就是实现简单、使用简单，只需要给变量上添加一个注解（@Autowired），就可以在不 new 对象的情况下，直接获得注入的对象了（这就是 DI 的功能和魅力所在），所以它的优点就是使用简单。</p> <p>然而，属性注入虽然使用简单，但也存在着很多问题，甚至编译器 Idea 都会提醒你“不建议使用此注入方式”。</p> <p><strong>② Setter 注入</strong></p> <p>Setter 注入的实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token comment">// Setter 注入</span>
    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setUserService</span><span class="token punctuation">(</span><span class="token class-name">UserService</span> userService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/add&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">UserInfo</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>从上面代码可以看出，Setter 注入比属性注入要麻烦很多。</p> <p>Setter 注入的优点是它完全符合单一职责的设计原则，因为每一个 Setter 只针对一个对象。</p> <p><strong>③ 构造方法注入</strong></p> <p>构造方法注入是 Spring 官方从 4.x 之后推荐的注入方式，它的实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token comment">// 构造方法注入</span>
    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token class-name">UserController</span><span class="token punctuation">(</span><span class="token class-name">UserService</span> userService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/add&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">UserInfo</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>当然，<strong>如果当前的类中只有一个构造方法，那么 @Autowired 也可以省略</strong>，所以以上代码还可以这样写：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span> <span class="token punctuation">{</span>

    <span class="token comment">// 构造方法注入</span>
    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">UserController</span><span class="token punctuation">(</span><span class="token class-name">UserService</span> userService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>userService <span class="token operator">=</span> userService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/add&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">UserInfo</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> userService<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p><strong>优点分析</strong></p> <p>构造方法注入相比于前两种注入方法，它可以注入不可变对象，并且它只会执行一次，也不存在像 Setter 注入那样，被注入的对象随时被修改的情况，它的优点有以下 4 个：</p> <ol><li>可注入不可变对象；</li> <li>注入对象不会被修改；</li> <li>注入对象会被完全初始化；</li> <li>通用性更好。</li></ol> <p><strong>优点1：注入不可变对象</strong></p> <p>使用构造方法注入可以注入不可变对象</p> <p><strong>优点2：注入对象不会被修改</strong></p> <p>构造方法注入不会像 Setter 注入那样，构造方法在对象创建时只会执行一次，因此它不存在注入对象被随时（调用）修改的情况。</p> <p><strong>优点3：完全初始化</strong></p> <p>因为依赖对象是在构造方法中执行的，而构造方法是在对象创建之初执行的，因此被注入的对象在使用之前，会被完全初始化，这也是构造方法注入的优点之一。</p> <p><strong>优点4：通用性更好</strong></p> <p>构造方法和属性注入不同，构造方法注入可适用于任何环境，无论是 IoC 框架还是非 IoC 框架，构造方法注入的代码都是通用的，所以它的通用性更好。</p> <p><strong>小结</strong></p> <p>依赖注入的常见实现方式有 3 种：属性注入、Setter 注入和构造方法注入。其中属性注入的写法最简单，所以日常项目中使用的频率最高，但它的通用性不好；而 Spring 官方推荐的是构造方法注入，它可以注入不可变对象，其通用性也更好，如果是注入可变对象，那么可以考虑使用 Setter 注入。</p> <h3 id="属性注入有什么缺点"><a href="#属性注入有什么缺点" class="header-anchor">#</a> 属性注入有什么缺点？</h3> <p>属性注入的缺点主要包含以下 3 个：</p> <ol><li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li> <li>通用性问题：只能适应于 IoC 容器；</li> <li>设计原则问题：更容易违背单一设计原则。</li></ol> <p><strong>缺点1：功能性问题</strong></p> <p>使用属性注入无法注入一个不可变的对象（final 修饰的对象）</p> <p>原因也很简单：在 Java 中 final 对象（不可变）要么直接赋值，要么在构造方法中赋值，所以当使用属性注入 final 对象时，它不符合 Java 中 final 的使用规范，所以就不能注入成功了。</p> <p><strong>缺点2：通用性问题</strong></p> <p>使用属性注入的方式只适用于 IoC 框架（容器），如果将属性注入的代码移植到其他非 IoC 的框架中，那么代码就无效了，所以属性注入的通用性不是很好。</p> <p><strong>缺点3：设计原则问题</strong></p> <p>使用属性注入的方式，因为使用起来很简单，所以开发者很容易在一个类中同时注入多个对象，而这些对象的注入是否有必要？是否符合程序设计中的单一职责原则？就变成了一个问题。</p> <p>但可以肯定的是，注入实现越简单，那么滥用它的概率也越大，所以出现违背单一职责原则的概率也越大。</p> <p>注意：这里强调的是违背设计原则（单一职责）的可能性，而不是一定会违背设计原则，二者有着本质的区别。</p> <h3 id="setter-注入有什么缺点"><a href="#setter-注入有什么缺点" class="header-anchor">#</a> Setter 注入有什么缺点？</h3> <p>它的缺点主要体现在以下 2 点：</p> <ol><li>不能注入不可变对象（final 修饰的对象）；</li> <li>注入的对象可被修改。</li></ol> <p><strong>缺点1：不能注入不可变对象</strong></p> <p>使用 Setter 注入依然不能注入不可变对象。</p> <p><strong>缺点2：注入对象可被修改</strong></p> <p>Setter 注入提供了 setXXX 的方法，意味着你可以在任何时候、在任何地方，通过调用 setXXX 的方法来改变注入对象，所以 Setter 注入的问题是，被注入的对象可能随时被修改。</p> <h3 id="推荐使用哪种注入方式"><a href="#推荐使用哪种注入方式" class="header-anchor">#</a> 推荐使用哪种注入方式？</h3> <p><strong>参考答案</strong>：Spring 官方推荐使用构造方法注入，原因如下：</p> <ol><li>属性注入的优点是简洁，使用方便；缺点是只能用于 IoC 容器，如果是非 IoC 容器不可用，并且只有在使用的时候才会出现 NPE（空指针异常）；</li> <li><strong>构造方法注入是 Spring 推荐的注入方式</strong>，它的缺点是如果有多个注入会显得比较臃肿，但出现这种情况你应该考虑一下当前类是否符合程序的单一职责的设计模式了，它的优点是通用性，在使用之前一定能把保证注入的类不为空；</li> <li>Setter 方式是 Spring 前期版本推荐的注入方式，但通用性不如构造方法，所有 Spring 现版本已经推荐使用构造方法注入的方式来进行类注入了。</li></ol> <h3 id="autowired-和-resource-有什么区别"><a href="#autowired-和-resource-有什么区别" class="header-anchor">#</a> @Autowired 和 @Resource 有什么区别？</h3> <p>@Autowired 和 @Resource 都是用来实现依赖注入的注解（在 Spring/Spring Boot 项目中），但二者却有着 5 点不同：</p> <ol><li>来源不同：@Autowired 来自 Spring 框架，而 @Resource 来自于（Java）JSR-250；</li> <li>依赖查找的顺序不同：@Autowired 先根据类型再根据名称查询，而 @Resource 先根据名称再根据类型查询；</li> <li>支持的参数不同：@Autowired 只支持设置 1 个参数，而 @Resource 支持设置 7 个参数；</li> <li>依赖注入的用法支持不同：@Autowired 既支持构造方法注入，又支持属性注入和 Setter 注入，而 @Resource 只支持属性注入和 Setter 注入；</li> <li>编译器 IDEA 的提示不同：当注入 Mapper 对象时，使用 @Autowired 注解编译器会提示错误，而使用 @Resource 注解则不会提示错误。</li></ol> <h3 id="bean-有几种作用域"><a href="#bean-有几种作用域" class="header-anchor">#</a> Bean 有几种作用域？</h3> <p>Bean 的作用域是指 Bean 在 Spring 整个框架中的某种行为模式。比如 singleton 单例作用域，就表示 Bean 在整个 Spring 中只有一份，它是全局共享的，当有人修改了这个值之后，那么另一个人读取到的就是被修改后的值。</p> <p>在 Spring 中，Bean 的常见作用域有以下 5 种：</p> <ol><li>singleton：单例作用域；</li> <li>prototype：原型作用域（多例作用域）；</li> <li>request：请求作用域（适用于 Spring MVC ）；</li> <li>session：会话作用域（适用于 Spring MVC ）；</li> <li>application：全局作用域（适用于 Spring MVC ）。</li></ol> <p><strong>① singleton</strong></p> <ol><li>官方说明：(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.</li> <li>描述：该作用域下的 Bean 在 IoC 容器中只存在一个实例：获取 Bean（即通过 applicationContext.getBean等方法获取）及装配 Bean（即通过 @Autowired 注入）都是同一个对象。</li> <li>场景：通常无状态的 Bean 使用该作用域。无状态表示 Bean 对象的属性状态不需要更新。</li> <li>备注：Spring 默认选择该作用域。</li></ol> <p><strong>② prototype</strong></p> <ol><li>官方说明：Scopes a single bean definition to any number of object instances.</li> <li>描述：每次对该作用域下的 Bean 的请求都会创建新的实例：获取 Bean（即通过 applicationContext.getBean 等方法获取）及装配 Bean（即通过 @Autowired 注入）都是新的对象实例。</li> <li>场景：通常有状态的 Bean 使用该作用域。</li></ol> <p><strong>③ request</strong></p> <ol><li>官方说明：Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.</li> <li>描述：每次 Http 请求会创建新的 Bean 实例，类似于 prototype。</li> <li>场景：一次 Http 的请求和响应的共享 Bean。</li> <li>备注：限定 Spring MVC 框架中使用。</li></ol> <p><strong>④ session</strong></p> <ol><li>官方说明：Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.</li> <li>描述：在一个 Http Session 中，定义一个 Bean 实例。</li> <li>场景：用户会话的共享 Bean, 比如：记录一个用户的登陆信息。</li> <li>备注：限定 Spring MVC 框架中使用。</li></ol> <p><strong>⑤ application</strong></p> <ol><li>官方说明：Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.</li> <li>描述：在一个 Http Servlet Context 中，定义一个 Bean 实例。</li> <li>场景：Web 应用的上下文信息，比如：记录一个应用的共享信息。</li> <li>备注：限定 Spring MVC 框架中使用。</li></ol> <h3 id="如何设置-bean-作用域"><a href="#如何设置-bean-作用域" class="header-anchor">#</a> 如何设置 Bean 作用域？</h3> <p>可以通过 @Scope  注解来设置 Bean 的作用域，它的设置方式有以下两种：</p> <ol><li>直接设置作用域的具体值，如：@Scope(&quot;prototype&quot;)；</li> <li>设置 ConfigurableBeanFactory 和 WebApplicationContext 提供的 SCOPE_XXX 变量，如 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)。</li></ol> <h3 id="说一下-bean-的生命周期"><a href="#说一下-bean-的生命周期" class="header-anchor">#</a> 说一下 Bean 的生命周期？</h3> <p>Spring 中 Bean 的生命周期是指：Bean 在 Spring（IoC）中从创建到销毁的整个过程。</p> <p>Spring 中 Bean 的生命周期主要包含以下 5 部分：</p> <ol><li>实例化：为 Bean 分配内存空间；</li> <li>设置属性：将当前类依赖的 Bean 属性，进行注入和装配；</li> <li>初始化：</li> <li>执行各种通知；</li> <li>执行初始化的前置方法；</li> <li>执行初始化方法；</li> <li>执行初始化的后置方法。</li> <li>使用 Bean：在程序中使用 Bean 对象；</li> <li>销毁 Bean：将 Bean 对象进行销毁操作。</li></ol> <p>以上生命周期中，需要注意的是：“实例化”和“初始化”是两个完全不同的过程，千万不要搞混，实例化只是给 Bean 分配了内存空间，而初始化则是将程序的执行权，从系统级别转换到用户级别，并开始执行用户添加的业务代码。</p> <h3 id="spring-使用了哪些设计模式"><a href="#spring-使用了哪些设计模式" class="header-anchor">#</a> Spring 使用了哪些设计模式？</h3> <p>Spring 框架使用的设计模式如下：</p> <ol><li>代理模式：在 AOP 中有使用；</li> <li>单例模式：bean 默认是单例模式；</li> <li>模板方法模式：jdbcTemplate；</li> <li>工厂模式：BeanFactory；</li> <li>观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件；</li> <li>适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller。</li></ol> <h3 id="spring-mvc-和-spring-有什么区别"><a href="#spring-mvc-和-spring-有什么区别" class="header-anchor">#</a> Spring MVC 和 Spring 有什么区别？</h3> <p>Spring MVC 的正式名称“Spring Web MVC”来自其源模块的名称(Spring-webmvc)，但它通常被称为“Spring MVC”。Spring MVC 是基于 Servlet API 构建的原始 Web 框架。而 Spring 是 Spring Framework 简称。</p> <p>简单来说，Spring MVC 是基于 Spring 功能之上添加的 Web 框架。</p> <h3 id="mvc-有什么优点"><a href="#mvc-有什么优点" class="header-anchor">#</a> MVC 有什么优点？</h3> <p>MVC 是 Model View Controller 的缩写，它是软件工程中的一种软件架构模式，它把软件系统分为模型、视图和控制器三个基本部分：</p> <ol><li>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据；</li> <li>View（视图）是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的；</li> <li>Controller（控制器）是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ol> <p>MVC 的优点是：</p> <ol><li>分层设计，实现了业务系统各个组件之间的解耦，有利于业务系统的可扩展性，可维护性；</li> <li>有利于系统的并行开发，提升开发效率。</li></ol> <h3 id="说一下-spring-mvc-执行流程"><a href="#说一下-spring-mvc-执行流程" class="header-anchor">#</a> 说一下 Spring MVC 执行流程？</h3> <p>SpringMVC 的执行流程如下：</p> <ol><li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li> <li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。</li> <li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li> <li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li> <li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li> <li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li> <li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li> <li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li> <li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li> <li>视图负责将结果显示到浏览器（客户端）。</li></ol> <h3 id="spring-mvc-重要组件有哪些"><a href="#spring-mvc-重要组件有哪些" class="header-anchor">#</a> Spring MVC 重要组件有哪些？</h3> <p>Spring MVC 涉及到的组件有 DispatcherServlet（前端控制器）、HandlerMapping（处理器映射器）、HandlerAdapter（处理器适配器）、Handler（处理器）、ViewResolver（视图解析器）和 View（视图）。下面对各个组件的功能说明如下。</p> <p><strong>① DispatcherServlet</strong></p> <p>DispatcherServlet 是前端控制器，Spring MVC 的所有请求都要经过 DispatcherServlet 来统一分发。DispatcherServlet 相当于一个转发器或中央处理器，控制整个流程的执行，对各个组件进行统一调度，以降低组件之间的耦合性，有利于组件之间的拓展。</p> <p><strong>② HandlerMapping</strong></p> <p>HandlerMapping 是处理器映射器，其作用是根据请求的 URL 路径，通过注解或者 XML 配置，寻找匹配的处理器（Handler）信息。</p> <p><strong>③ HandlerAdapter</strong></p> <p>HandlerAdapter 是处理器适配器，其作用是根据映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler）。</p> <p><strong>④ Handler</strong></p> <p>Handler 是处理器，和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中。</p> <p><strong>⑤ View Resolver</strong></p> <p>View Resolver 是视图解析器，其作用是进行解析操作，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面）。</p> <p><strong>⑥ View</strong></p> <p>View 是视图，其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）。</p> <p>以上组件中，需要开发人员进行开发的是处理器（Handler，常称Controller）和视图（View）。通俗的说，要开发处理该请求的具体代码逻辑，以及最终展示给用户的界面。</p> <h3 id="如何进行路由注册"><a href="#如何进行路由注册" class="header-anchor">#</a> 如何进行路由注册？</h3> <p>在 Spring MVC 通常会使用注解的方式来实现路由注册，常见的路由注册注解有：</p> <ol><li>@RequestMapping 既支持 POST 类型的请求又支持 GET 类型的请求；</li> <li>@GetMapping 只支持 GET 类型的请求；</li> <li>@PostMapping 只支持 POST 类型的请求。</li></ol> <h3 id="怎么接收-json-格式参数"><a href="#怎么接收-json-格式参数" class="header-anchor">#</a> 怎么接收 JSON 格式参数？</h3> <p>后端要使用 @RequestBody 来接收前端 JSON 格式的参数。</p> <h3 id="如何从-url-中获取参数"><a href="#如何从-url-中获取参数" class="header-anchor">#</a> 如何从 URL 中获取参数？</h3> <p>可以使用注解 @PathVariable 注解从 URL 中获取参数，如下代码所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@PostMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/login/{name}/{password}&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">String</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;name：&quot;</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;password：&quot;</span> <span class="token operator">+</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">&quot;redirect:/index.html&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="如何获取并保存前端上传的文件"><a href="#如何获取并保存前端上传的文件" class="header-anchor">#</a> 如何获取并保存前端上传的文件？</h3> <p>后端使用 @RequestPart 加 MultipartFile 来获取前端上传的参数，之后再使用 MultipartFile 提供的 transferTo 方法保存接收的文件，示例代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/upload&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">upload</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestPart</span><span class="token punctuation">(</span><span class="token string">&quot;myfile&quot;</span><span class="token punctuation">)</span> <span class="token class-name">MultipartFile</span> file<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获取文件后缀名</span>
    <span class="token class-name">String</span> fileName <span class="token operator">=</span> file<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">getOriginalFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 文件保存地址</span>
    <span class="token class-name">String</span> filePath <span class="token operator">=</span> <span class="token class-name">ClassUtils</span><span class="token punctuation">.</span><span class="token function">getDefaultClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token string">&quot;static&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
         <span class="token string">&quot;/&quot;</span> <span class="token operator">+</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> fileName<span class="token punctuation">;</span>
    <span class="token comment">// 保存文件</span>
    file<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>filePath<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> filePath <span class="token operator">+</span> <span class="token string">&quot; 上传成功.&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="怎么实现请求转发和请求重定向"><a href="#怎么实现请求转发和请求重定向" class="header-anchor">#</a> 怎么实现请求转发和请求重定向？</h3> <p>在 Spring MVC 中，可以使用 forward 进行请求转发，使用 redirect 实现请求重定向，示例代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token comment">// 请求转发</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/fd&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">fd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;forward:/index.html&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 请求重定向</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/rd&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">rd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&quot;redirect:/index.html&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="请求转发和请求重定向有什么区别"><a href="#请求转发和请求重定向有什么区别" class="header-anchor">#</a> 请求转发和请求重定向有什么区别？</h3> <p>请求转发和请求重定向主要区别有以下 4 点：</p> <ol><li>定义不同：</li> <li>请求转发（Forward）：发生在服务端程序内部，当服务器端收到一个客户端的请求之后，会先将请求，转发给目标地址，再将目标地址返回的结果转发给客户端。而客户端对于这一切毫无感知的，这就好比，张三（客户端）找李四（服务器端）借钱，而李四没钱，于是李四又去王五那借钱，并把钱借给了张三，整个过程中张三只借了一次款，剩下的事情都是李四完成的，这就是请求转发。</li> <li>请求重定向（Redirect）：请求重定向指的是服务器端接收到客户端的请求之后，会给客户端返回了一个临时响应头，这个临时响应头中记录了，客户端需要再次发送请求（重定向）的 URL 地址，客户端再收到了地址之后，会将请求发送到新的地址上，这就是请求重定向。这就好像张三（客户端）找李四（服务器端）借钱，李四没钱，于是李四就告诉张三，“我没钱，你去王五那借“，于是张三又去王五家借到了钱，这就是请求重定向。</li> <li>跳转方不同：请求转发是服务器端的行为，服务器端代替客户端发送请求，并将结果返回给客户端；而请求重定向是客户端的行为；</li> <li>数据共享不同：请求转发是服务器端实现的，所以整个执行流程中，客户端（浏览器端）只需要发送一次请求，因此整个交互过程中使用的都是同一个 Request 请求对象和一个 Response 响应对象，所以整个请求过程中，请求和返回的数据是共享的；而请求重定向客户端发送两次完全不同的请求，所以两次请求中的数据是不同的；</li> <li>最终 URL 地址不同：请求转发是服务器端代为请求，再将结果返回给客户端的，所以整个请求的过程中 URL 地址是不变的；而请求重定向是服务器端告诉客户端，“你去另一个地访问去”，所以浏览器会重新再发送一次请求，因此客户端最终显示的 URL 也为最终跳转的地址，而非刚开始请求的地址，所以 URL 地址发生了改变。</li></ol> <h3 id="spring-mvc-中文乱码问题应该如何处理"><a href="#spring-mvc-中文乱码问题应该如何处理" class="header-anchor">#</a> Spring MVC 中文乱码问题应该如何处理？</h3> <p>中文乱码问题通常需要设置以下两个地方。</p> <p><strong>① 在 web.xml 添加编码过滤器</strong></p> <p>配置如下：</p> <div class="language-xml line-numbers-mode"><pre class="language-xml"><code>&lt;filter###
	&lt;filter-name###encodingFilter&lt;/filter-name###
	&lt;filter-class###org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class###
	&lt;init-param###
		&lt;param-name###encoding&lt;/param-name###
		&lt;param-value###UTF-8&lt;/param-value###
	&lt;/init-param###
&lt;/filter###

&lt;filter-mapping###
	&lt;filter-name###encodingFilter&lt;/filter-name###
	&lt;url-pattern###/*&lt;/url-pattern###
&lt;/filter-mapping###
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>② RequestMapping 中设置编码</strong></p> <p>设置 RequestMapping 的 produces 属性，指定返回值类型和编码，如下所示：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value  <span class="token operator">=</span> <span class="token string">&quot;/add&quot;</span><span class="token punctuation">,</span> produces <span class="token operator">=</span> <span class="token string">&quot;text/plain;charset=utf-8&quot;</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="request-有几种获取方式"><a href="#request-有几种获取方式" class="header-anchor">#</a> request 有几种获取方式？</h3> <p>Spring MVC 获取 request 有以下 3 种方式：</p> <p>① <strong>从请求参数中获取</strong></p> <p>示例代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/index&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span><span class="token punctuation">{</span>
　　<span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>该方法实现的原理是 Controller 开始处理请求时，Spring 会将 request 对象赋值到方法参数中。</p> <p><strong>② 通过 RequestContextHolder上下文获取 request 对象</strong></p> <p>示例代码：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/index&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@ResponseBody</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token class-name">ServletRequestAttributes</span> servletRequestAttributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span><span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">HttpServletRequest</span> request <span class="token operator">=</span> servletRequestAttributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><strong>③ 通过自动注入的方式</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@Controller</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HomeController</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">;</span> <span class="token comment">// 自动注入 request 对象</span>
    <span class="token comment">// do something</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="spring-mvc-如何处理跨域问题"><a href="#spring-mvc-如何处理跨域问题" class="header-anchor">#</a> Spring MVC 如何处理跨域问题？</h3> <p>可以在 Spring MVC 中重写 addCorsMappings 中配置跨域问题，具体实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Bean</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>config<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">CorsRegistry</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>config<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebMvcConfigurer</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyConfiguration</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token function">corsConfigurer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WebMvcConfigurer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCorsMappings</span><span class="token punctuation">(</span><span class="token class-name">CorsRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 设置允许跨域的请求规则</span>
                registry<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/api/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="为什么会有跨域问题"><a href="#为什么会有跨域问题" class="header-anchor">#</a> 为什么会有跨域问题？</h3> <p>跨域问题本质是浏览器为了保证用户的访问安全，防止恶意网站窃取数据，所制定的一套安全策略。</p> <p>而解决跨域问题只需要告诉浏览器这是一个安全的请求“是自己人”，它的实现是在响应头中加了一个 Access-Control-Allow-Origin 为“*”的响应头而已，告诉浏览器“是自己人”。</p> <p>Spring MVC 中重写 addCorsMappings 方法就是配置哪些 URL 需要在响应头中加了一个 Access-Control-Allow-Origin 属性。</p> <h3 id="spring-和-spring-boot-有什么区别"><a href="#spring-和-spring-boot-有什么区别" class="header-anchor">#</a> Spring 和 Spring Boot 有什么区别？</h3> <p>作为 Java 开发人员对 Spring 框架都很熟悉，Spring 为 Java 程序提供了全面的基础架构支持，包含了很多非常实用的功能，如 Spring JDBC、Spring AOP、Spring ORM、Spring Test 等，这些模块的出现，大大的缩短了应用程序的开发时间，同时提高了应用开发的效率。</p> <p>Spring Boot 本质上是 Spring 框架的延伸和扩展，它的诞生是为了简化 Spring 框架初始搭建以及开发的过程，使用它可以不再依赖 Spring 应用程序中的 XML 配置，为更快、更高效的开发 Spring 提供更加有力的支持。</p> <h3 id="spring-boot-有什么优点"><a href="#spring-boot-有什么优点" class="header-anchor">#</a> Spring Boot 有什么优点？</h3> <p>Spring Boot 具有以下特点：</p> <ol><li>开发变得简单：提供一键式项目创建和快速集成各种依赖功能；</li> <li>配置变得简单：提供了丰富的 Starters，集成主流开源产品往往只需要简单的配置即可；</li> <li>部署变得简单：其本身内嵌启动容器，仅仅需要一个命令即可启动项目，结合 Jenkins、Docker 自动化运维非常容易实现；</li> <li>监控变得简单：提供了监控组件，使用 Actuator 轻松监控服务各项状态。</li></ol> <h3 id="说一下-spring-boot-启动流程"><a href="#说一下-spring-boot-启动流程" class="header-anchor">#</a> 说一下 Spring Boot 启动流程？</h3> <p>Spring Boot 启动流程要从 main 方法的 run 源码说起，它的源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConfigurableApplicationContext</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1.创建并启动计时监控类</span>
    <span class="token class-name">StopWatch</span> stopWatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StopWatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stopWatch<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 2.声明应用上下文对象和异常报告集合</span>
    <span class="token class-name">ConfigurableApplicationContext</span> context <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token class-name">Collection</span><span class="token operator">&lt;</span><span class="token class-name">SpringBootExceptionReporter</span>### exceptionReporters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 3.设置系统属性 headless 的值</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configureHeadlessProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 4.创建所有 Spring 运行监听器并发布应用启动事件</span>
    <span class="token class-name">SpringApplicationRunListeners</span> listeners <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getRunListeners</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    listeners<span class="token punctuation">.</span><span class="token function">starting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Collection</span> exceptionReporters<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 5.处理 args 参数</span>
        <span class="token class-name">ApplicationArguments</span> applicationArguments <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultApplicationArguments</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 6.准备环境</span>
        <span class="token class-name">ConfigurableEnvironment</span> environment <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareEnvironment</span><span class="token punctuation">(</span>listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">configureIgnoreBeanInfo</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 7.创建 Banner 的打印类</span>
        <span class="token class-name">Banner</span> printedBanner <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">printBanner</span><span class="token punctuation">(</span>environment<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 8.创建应用上下文</span>
        context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 9.实例化异常报告器</span>
        exceptionReporters <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSpringFactoriesInstances</span><span class="token punctuation">(</span><span class="token class-name">SpringBootExceptionReporter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token class-name">ConfigurableApplicationContext</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 10.准备应用上下文</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareContext</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> environment<span class="token punctuation">,</span> listeners<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">,</span> printedBanner<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 11.刷新应用上下文</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">refreshContext</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 12.应用上下文刷新之后的事件的处理</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterRefresh</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 13.停止计时监控类</span>
        stopWatch<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 14.输出日志记录执行主类名、时间信息</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>logStartupInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StartupInfoLogger</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mainApplicationClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">logStarted</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getApplicationLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stopWatch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 15.发布应用上下文启动完成事件</span>
        listeners<span class="token punctuation">.</span><span class="token function">started</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 16.执行所有 Runner 运行器</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">callRunners</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> applicationArguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var10<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> var10<span class="token punctuation">,</span> exceptionReporters<span class="token punctuation">,</span> listeners<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>var10<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 17.发布应用上下文就绪事件</span>
        listeners<span class="token punctuation">.</span><span class="token function">running</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 18.返回应用上下文对象</span>
        <span class="token keyword">return</span> context<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var9<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleRunFailure</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> var9<span class="token punctuation">,</span> exceptionReporters<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">SpringApplicationRunListeners</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>var9<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br></div></div><p>从以上源码可以看出 Spring Boot 的启动总共分为以下 18 个步骤。</p> <p><strong>1.创建并启动计时监控类</strong></p> <p>此计时器是为了监控并记录 Spring Boot 应用启动的时间的，它会记录当前任务的名称，然后开启计时器。</p> <p><strong>2.声明应用上下文对象和异常报告集合</strong></p> <p>此过程声明了应用上下文对象和一个异常报告的 ArrayList 集合。</p> <p><strong>3.设置系统属性 headless 的值</strong></p> <p>设置 Java.awt.headless = true，其中awt（Abstract Window Toolkit）的含义是抽象窗口工具集。设置为 true表示运行一个 headless 服务器，可以用它来作一些简单的图像处理。</p> <p><strong>4.创建所有 Spring 运行监听器并发布应用启动事件</strong></p> <p>此过程用于获取配置的监听器名称并实例化所有的类。</p> <p><strong>5.初始化默认应用的参数类</strong></p> <p>也就是说声明并创建一个应用参数对象。</p> <p><strong>6.准备环境</strong></p> <p>创建配置并且绑定环境（通过 property sources 和 profiles 等配置文件）。</p> <p><strong>7.创建 Banner 的打印类</strong></p> <p>Spring Boot 启动时会打印 Banner 图片</p> <p>此 banner 信息是在 SpringBootBanner 类中定义的，我们可以通过实现 Banner 接口来自定义 banner 信息，然后通过代码 setBanner() 方法设置 Spring Boot 项目使用自己自定义 Banner 信息，或者是在 resources 下添加一个 banner.txt，把 banner 信息添加到此文件中，就可以实现自定义 banner 的功能了。</p> <p><strong>8.创建应用上下文</strong></p> <p>根据不同的应用类型来创建不同的 ApplicationContext上下文对象。</p> <p><strong>9.实例化异常报告器</strong></p> <p>它调用的是 getSpringFactoriesInstances() 方法来获取配置异常类的名称，并实例化所有的异常处理类。</p> <p><strong>10.准备应用上下文</strong></p> <p>此方法的主要作用是把上面已经创建好的对象，传递给 prepareContext 来准备上下文，例如将环境变量 environment 对象绑定到上下文中、配置 bean 生成器以及资源加载器、记录启动日志等操作。</p> <p><strong>11.刷新应用上下文</strong></p> <p>此方法用于解析配置文件，加载 bean 对象，并且启动内置的 web 容器等操作。</p> <p><strong>12.应用上下文刷新之后的事件处理</strong></p> <p>这个方法的源码是空的，可以做一些自定义的后置处理操作。</p> <p><strong>13.停止计时监控类</strong></p> <p>停止此过程第一步中的程序计时器，并统计任务的执行信息。</p> <p><strong>14.输出日志信息</strong></p> <p>把相关的记录信息，如类名、时间等信息进行控制台输出。</p> <p><strong>15.发布应用上下文启动完成事件</strong></p> <p>触发所有 SpringApplicationRunListener 监听器的 started 事件方法。</p> <p><strong>16.执行所有 Runner 运行器</strong></p> <p>执行所有的 ApplicationRunner 和 CommandLineRunner 运行器。</p> <p><strong>17.发布应用上下文就绪事件</strong></p> <p>触发所有的 SpringApplicationRunListener 监听器的 running 事件。</p> <p><strong>18.返回应用上下文对象</strong></p> <p>到此为止 SpringBoot 的启动程序就结束了，我们就可以正常来使用 Spring Boot 框架了。</p> <h3 id="ant、maven-和-gradle-有什么区别"><a href="#ant、maven-和-gradle-有什么区别" class="header-anchor">#</a> Ant、Maven 和 Gradle 有什么区别？</h3> <p>Ant、Maven、Gradle 是 Java 领域中主要有三大构建工具，它们的区别如下：</p> <ol><li>Ant（AnotherNeatTool）诞生于 2000 年，是由 Java 编写，采用 XML 作为构建脚本，这样就允许你在任何环境下运行构建。Ant 是 Java 领域最早的构建工具，不过因为操作复杂，慢慢的已经被淘汰了；</li> <li>Maven 诞生于 2004 年，目的是解决程序员使用 Ant 所带来的一些问题，它的好处在于可以将项目过程规范化、自动化、高效化以及强大的可扩展性；</li> <li>Gradle 诞生于 2009 年，是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化建构工具。它使用一种基于 Groovy 的特定领域语言来声明项目设置，而不是传统的 XML。结合了前两者的优点，在此基础之上做了很多改进，它具有 Ant 的强大和灵活，又有 Maven 的生命周期管理且易于使用。</li></ol> <p>Spring Boot 官方支持 Maven 和 Gradle 作为项目构建工具。Gradle 虽然有更好的理念，但是相比 Maven 来讲其行业使用率偏低。</p> <h3 id="properties-和-yml-有什么区别"><a href="#properties-和-yml-有什么区别" class="header-anchor">#</a> properties 和 yml 有什么区别？</h3> <p>properties 和 yml 都是 Spring Boot 支持的两种配置文件，其中 yml 格式的配置文件可以看作是对 properties  配置文件的升级。它们的主要区别有 4 点：</p> <ol><li>定义和定位不同：properties 翻译成中文是“属性”的意思，properties 只是用来设置一些属性配置的；yml 是 YAML 是缩写，它的全称 Yet Another Markup Language，翻译成中文是“另一种标记语言”。它的定位是“另一种标记语言”，所以从格局上来讲 yml 就甩 properties 好几条街；</li> <li>语法不同：yml 的语法更简单，且可读性更高；</li> <li>支持数据类型不同：yml 可以更好的配置多种数据类型，比如对象、集合等；</li> <li>跨语言不同：yml 可以跨语言使用，通用性更好。</li></ol> <h3 id="springboot-如何读取配置文件"><a href="#springboot-如何读取配置文件" class="header-anchor">#</a> SpringBoot 如何读取配置文件？</h3> <p>在 Spring Boot 中读取配置文件有以下 5 种方法：</p> <ol><li>使用 @Value 读取配置文件。</li> <li>使用 @ConfigurationProperties 读取配置文件。</li> <li>使用 @PropertySource 读取配置文件。</li> <li>使用 Environment 读取配置文件。</li> <li>使用原生方式读取配置文件。</li></ol> <p>其中最常用的是前 3 种，如果读取某一个配置项可使用 @Value，如果读取一组配置项可使用 @ConfigurationProperties，如果要指定读取某一个具体的配置文件可使用 @PropertySource 来指定。</p> <h3 id="配置文件中中文乱码问题如何处理"><a href="#配置文件中中文乱码问题如何处理" class="header-anchor">#</a> 配置文件中中文乱码问题如何处理？</h3> <p>配置文件中的中文乱码问题的解决方案如下：</p> <ol><li>将配置文件的编码格式设置为支持中文的 UTF-8 格式；</li> <li>使用 @PropertySource 设置支持中文的 UTF-8 格式读取，如 @PropertySource(value = &quot;dev.properties&quot;, encoding = &quot;utf-8&quot;)。</li></ol> <h3 id="如何实现拦截器"><a href="#如何实现拦截器" class="header-anchor">#</a> 如何实现拦截器？</h3> <p>在 Spring Boot 中拦截器的实现分为两步：</p> <ol><li>创建一个普通的拦截器，实现 HandlerInterceptor 接口，并重写接口中的相关方法；</li> <li>将上一步创建的拦截器加入到 Spring Boot 的配置文件中，并配置拦截规则。</li></ol> <p>具体实现如下。</p> <p><strong>① 实现自定义拦截器</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">HandlerInterceptor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token class-name">ModelAndView</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletResponse</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerInterceptor</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;拦截器：执行 preHandle 方法。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postHandle</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">ModelAndView</span> modelAndView<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;拦截器：执行 postHandle 方法。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterCompletion</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">Object</span> handler<span class="token punctuation">,</span> <span class="token class-name">Exception</span> ex<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;拦截器：执行 afterCompletion 方法。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>其中：</p> <ol><li>boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)：在请求方法执行前被调用，也就是调用目标方法之前被调用。比如我们在操作数据之前先要验证用户的登录信息，就可以在此方法中实现，如果验证成功则返回 true，继续执行数据操作业务；否则就返回 false，后续操作数据的业务就不会被执行了。</li> <li>void postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)：调用请求方法之后执行，但它会在 DispatcherServlet 进行渲染视图之前被执行。</li> <li>void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)：会在整个请求结束之后再执行，也就是在 DispatcherServlet 渲染了对应的视图之后再执行。</li></ol> <p><strong>② 配置拦截规则</strong></p> <p>最后，我们再将上面的拦截器注入到项目配置文件中，并设置相应拦截规则，具体实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Configuration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>config<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">InterceptorRegistry</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>config<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebMvcConfigurer</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>

    <span class="token comment">// 注入拦截器</span>
    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> <span class="token class-name">TestInterceptor</span> testInterceptor<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addInterceptors</span><span class="token punctuation">(</span><span class="token class-name">InterceptorRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        registry<span class="token punctuation">.</span><span class="token function">addInterceptor</span><span class="token punctuation">(</span>testInterceptor<span class="token punctuation">)</span> <span class="token comment">// 添加拦截器</span>
                <span class="token punctuation">.</span><span class="token function">addPathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拦截所有地址</span>
        		<span class="token punctuation">.</span><span class="token function">excludePathPatterns</span><span class="token punctuation">(</span><span class="token string">&quot;/login&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 放行接口</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h3 id="如何实现过滤器"><a href="#如何实现过滤器" class="header-anchor">#</a> 如何实现过滤器？</h3> <p>过滤器可以使用 Servlet 3.0 提供的 @WebFilter 注解，配置过滤的 URL 规则，然后再实现 Filter 接口，重写接口中的 doFilter 方法，具体实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">javax<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">WebFilter</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@WebFilter</span><span class="token punctuation">(</span>urlPatterns <span class="token operator">=</span> <span class="token string">&quot;/*&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestFilter</span> <span class="token keyword">implements</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">FilterConfig</span> filterConfig<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;过滤器：执行 init 方法。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> servletRequest<span class="token punctuation">,</span>
                         <span class="token class-name">ServletResponse</span> servletResponse<span class="token punctuation">,</span>
                         <span class="token class-name">FilterChain</span> filterChain<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;过滤器：开始执行 doFilter 方法。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 请求放行</span>
        filterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>servletRequest<span class="token punctuation">,</span> servletResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;过滤器：结束执行 doFilter 方法。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;过滤器：执行 destroy 方法。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>其中：</p> <ol><li>void init(FilterConfig filterConfig)：容器启动（初始化 Filter）时会被调用，整个程序运行期只会被调用一次。用于实现 Filter 对象的初始化。</li> <li>void doFilter(ServletRequest request, ServletResponse response,FilterChain chain)：具体的过滤功能实现代码，通过此方法对请求进行过滤处理，<strong>其中 FilterChain 参数是用来调用下一个过滤器或执行下一个流程</strong>。</li> <li>void destroy()：用于 Filter 销毁前完成相关资源的回收工作。</li></ol> <h3 id="拦截器和过滤器有什么区别"><a href="#拦截器和过滤器有什么区别" class="header-anchor">#</a> 拦截器和过滤器有什么区别？</h3> <p>拦截器和过滤器的区别主要体现在以下 5 点：</p> <ol><li>出身不同：过滤器来自于 Servlet，而拦截器来自于 Spring 框架；</li> <li>触发时机不同：请求的执行顺序是：请求进入容器 ### 进入过滤器 ### 进入 Servlet ### 进入拦截器 ### 执行控制器（Controller），所以过滤器和拦截器的执行时机，是过滤器会先执行，然后才会执行拦截器，最后才会进入真正的要调用的方法；</li> <li>底层实现不同：过滤器是基于方法回调实现的，拦截器是基于动态代理（底层是反射）实现的。；</li> <li>支持的项目类型不同：过滤器是 Servlet 规范中定义的，所以过滤器要依赖 Servlet 容器，它只能用在 Web 项目中；而拦截器是 Spring 中的一个组件，因此拦截器既可以用在 Web 项目中，同时还可以用在 Application 或 Swing 程序中；</li> <li>使用的场景不同：因为拦截器更接近业务系统，所以拦截器主要用来实现项目中的业务判断的，比如：登录判断、权限判断、日志记录等业务；而过滤器通常是用来实现通用功能过滤的，比如：敏感词过滤、字符集编码设置、响应数据压缩等功能。</li></ol> <h3 id="如何操作事务"><a href="#如何操作事务" class="header-anchor">#</a> 如何操作事务？</h3> <p>在 Spring Boot 中操作事务有两种方式：编程式事务或声明式事务。</p> <p><strong>① 编程式事务有两种实现方法</strong></p> <ol><li>使用 TransactionTemplate 对象实现编程式事务；</li> <li>使用更加底层的 TransactionManager 对象实现编程式事务。</li></ol> <p><strong>a) TransactionTemplate 实现</strong></p> <p>要使用 TransactionTemplate  对象需要先将 TransactionTemplate 注入到当前类中 ，然后再使用它提供的 execute 方法执行事务并返回相应的执行结果，如果程序在执行途中出现了异常，那么就可以使用代码手动回滚事务。</p> <p><strong>b) TransactionManager 实现</strong></p> <p>TransactionManager 实现编程式事务相对麻烦一点，它需要使用两个对象：TransactionManager 的子类，加上 TransactionDefinition 事务定义对象，再通过调用 TransactionManager 的 getTransaction 获取并开启事务，然后调用 TransactionManager 提供的 commit 方法提交事务，或使用它的另一个方法 rollback 回滚事务。</p> <p><strong>② 声明式事务</strong></p> <p>声明式事务的实现比较简单，只需要在方法上或类上添加 @Transactional 注解即可，当加入了 @Transactional 注解就可以实现在方法执行前，自动开启事务；在方法成功执行完，自动提交事务；如果方法在执行期间，出现了异常，那么它会自动回滚事务。</p> <h3 id="导致-transactional-失效的场景有哪些"><a href="#导致-transactional-失效的场景有哪些" class="header-anchor">#</a> 导致 @Transactional 失效的场景有哪些？</h3> <p>导致 @Transactional 失效的常见场景有以下 5 个：</p> <ol><li>非 public 修饰的方法；</li> <li>timeout 超时时间设置过小：如果事务的超时时间设置过小，而方法执行时间过长（超过 timeout），那么事务也会失效；</li> <li>代码中使用 try/catch 处理异常；</li> <li>调用类内部的 @Transactional 方法；</li> <li>数据库不支持事务。</li></ol> <h3 id="为什么非-public-方法-transactional-会失效"><a href="#为什么非-public-方法-transactional-会失效" class="header-anchor">#</a> 为什么非 public 方法 @Transactional 会失效？</h3> <p>因为 @Transactional 使用的是 Spring AOP 实现的，而 Spring AOP 是通过动态代理实现的，而 @Transactional 在生成代理时会判断，如果方法为非 public 修饰的方法，则不生成代理对象，这样也就没办法自动执行事务了，它的部分实现源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">TransactionAttribute</span> <span class="token function">computeTransactionAttribute</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span>### targetClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 非 public 方法，设置为 null</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">allowPublicMethodsOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token class-name">Modifier</span><span class="token punctuation">.</span><span class="token function">isPublic</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">// 后面代码省略....</span>
 <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="为什么-try-catch-之后-事务不能自动回滚了"><a href="#为什么-try-catch-之后-事务不能自动回滚了" class="header-anchor">#</a> 为什么 try-catch 之后，事务不能自动回滚了？</h3> <p>造成这个问题的原因是和 @Transactional 注解的实现有关的，因为 @Transactional 在实现中，会捕捉异常，如果有异常了才会回滚事务，而程序中如果添加了 try-catch 之后，@Transactional 就感知不到异常了，从而也就不会回滚事务了，@Transactional 的部分实现源码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">invokeWithinTransaction</span><span class="token punctuation">(</span><span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span><span class="token operator">?</span>### targetClass<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">InvocationCallback</span> invocation<span class="token punctuation">)</span>
      <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
   <span class="token keyword">final</span> <span class="token class-name">TransactionAttribute</span> txAttr <span class="token operator">=</span> <span class="token function">getTransactionAttributeSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTransactionAttribute</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">final</span> <span class="token class-name">PlatformTransactionManager</span> tm <span class="token operator">=</span> <span class="token function">determineTransactionManager</span><span class="token punctuation">(</span>txAttr<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">final</span> <span class="token class-name">String</span> joinpointIdentification <span class="token operator">=</span> <span class="token function">methodIdentification</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> targetClass<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">if</span> <span class="token punctuation">(</span>txAttr <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>tm <span class="token keyword">instanceof</span> <span class="token class-name">CallbackPreferringPlatformTransactionManager</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 自动开启事务</span>
      <span class="token class-name">TransactionInfo</span> txInfo <span class="token operator">=</span> <span class="token function">createTransactionIfNecessary</span><span class="token punctuation">(</span>tm<span class="token punctuation">,</span> txAttr<span class="token punctuation">,</span> joinpointIdentification<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">Object</span> retVal <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
         <span class="token comment">// 反射调用业务方法</span>
         retVal <span class="token operator">=</span> invocation<span class="token punctuation">.</span><span class="token function">proceedWithInvocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 异常时，在 catch 逻辑中，自动回滚事务</span>
         <span class="token function">completeTransactionAfterThrowing</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">finally</span> <span class="token punctuation">{</span>
         <span class="token function">cleanupTransactionInfo</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
       <span class="token comment">// 自动提交事务</span>
      <span class="token function">commitTransactionAfterReturning</span><span class="token punctuation">(</span>txInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> retVal<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">else</span> <span class="token punctuation">{</span>
     <span class="token comment">// .....</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="如何处理事务不自动回滚的问题"><a href="#如何处理事务不自动回滚的问题" class="header-anchor">#</a> 如何处理事务不自动回滚的问题？</h3> <p>当 @Transactional 感知不到异常时，也就是程序中加入了 try-catch 之后事务就不自动回滚了，此时的解决方案有两种：</p> <ol><li>在 catch 中重新将异常抛出（这样 @Transactional 就能感知到异常了）；</li> <li>使用代码手动回滚事务。</li></ol> <p>具体实现如下。</p> <p><strong>① 重新抛出异常</strong></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/save&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>isolation <span class="token operator">=</span> <span class="token class-name">Isolation</span><span class="token punctuation">.</span><span class="token constant">SERIALIZABLE</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 业务代码...</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 异常代码</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 将异常重新抛出去</span>
        <span class="token keyword">throw</span> e<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>② 手动回滚事务</strong></p> <p>在方法中使用 TransactionAspectSupport.currentTransactionStatus() 可以得到当前的事务，然后设置回滚方法 setRollbackOnly 就可以实现回滚了，具体实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/save&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Transactional</span>
<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">save</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 插入数据库</span>
    <span class="token keyword">int</span> result <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// 异常代码</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 手动回滚事务        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h3 id="为什么调用类内部-transactional-事务会失效"><a href="#为什么调用类内部-transactional-事务会失效" class="header-anchor">#</a> 为什么调用类内部 @Transactional 事务会失效？</h3> <p>因为 @Transactional 是基于 Spring AOP 实现的，而 Spring AOP 又是基于动态代理实现的，而当调用类内部的方法时，不是通过代理对象完成的，而是通过 this 对象实现的，这样就绕过了代理对象，从而事务就失效了。</p> <h3 id="说一下-transactional-工作原理"><a href="#说一下-transactional-工作原理" class="header-anchor">#</a> 说一下 @Transactional 工作原理？</h3> <p>@Transactional 是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。@Transactional 在开始执行业务之前，通过代理先开启事务，在执行成功之后再提交事务。如果中途遇到的异常，则回滚事务。</p> <h3 id="spring-有几种事务隔离级别"><a href="#spring-有几种事务隔离级别" class="header-anchor">#</a> Spring 有几种事务隔离级别？</h3> <p>Spring 中事务隔离级别包含以下 5 种：</p> <ol><li>DEFAULT：Spring 默认的事务隔离级别，以连接的数据库的事务隔离级别为准；</li> <li>READ_UNCOMMITTED：读未提交，也叫未提交读，该隔离级别的事务可以看到其他事务中未提交的数据。该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据，把这个问题称之为脏读；</li> <li>READ_COMMITTED：读已提交，也叫提交读，该隔离级别的事务能读取到已经提交事务的数据，因此它不会有脏读问题。但由于在事务的执行中可以读取到其他事务提交的结果，所以在不同时间的相同 SQL 查询中，可能会得到不同的结果，这种现象叫做不可重复读；</li> <li>REPEATABLE_READ：可重复读，它能确保同一事务多次查询的结果一致。但也会有新的问题，比如此级别的事务正在执行时，另一个事务成功的插入了某条数据，但因为它每次查询的结果都是一样的，所以会导致查询不到这条数据，自己重复插入时又失败（因为唯一约束的原因）。明明在事务中查询不到这条信息，但自己就是插入不进去，这就叫幻读 （Phantom Read）；</li> <li>SERIALIZABLE：串行化，最高的事务隔离级别，它会强制事务排序，使之不会发生冲突，从而解决了脏读、不可重复读和幻读问题，但因为执行效率低，所以真正使用的场景并不多。</li></ol> <h3 id="说一下-spring-事务传播机制"><a href="#说一下-spring-事务传播机制" class="header-anchor">#</a> 说一下 Spring 事务传播机制？</h3> <p>Spring 事务传播机制是指，包含多个事务的方法在相互调用时，事务是如何在这些方法间传播的。</p> <p>Spring 事务传播机制可使用 @Transactional(propagation=Propagation.REQUIRED) 来定义，Spring 事务传播机制的级别包含以下 7 种：</p> <ol><li>Propagation.REQUIRED：默认的事务传播级别，它表示如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li> <li>Propagation.SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li> <li>Propagation.MANDATORY：（mandatory：强制性）如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li> <li>Propagation.REQUIRES_NEW：表示创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，Propagation.REQUIRES_NEW 修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</li> <li>Propagation.NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li> <li>Propagation.NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li> <li>Propagation.NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于 PROPAGATION_REQUIRED。</li></ol> <h3 id="加入事务和嵌套事务有什么区别"><a href="#加入事务和嵌套事务有什么区别" class="header-anchor">#</a> 加入事务和嵌套事务有什么区别？</h3> <p>加入事务（REQUIRED）和嵌套事务（NESTED）都是事务传播机制中的两种传播级别，如果当前不存在事务，那么二者的行为是一致的；但如果当前存在事务，那么加入事务的事务传播级别当遇到异常时会回滚全部事务，而嵌套事务则是回滚部分事务。嵌套事务之所以能回滚部分事务，是因为数据库中存在一个保存点的概念，嵌套事务相对于新建了一个保存点，如果出现异常了，那么只需要回滚到保存点即可，这样就实现了部分事务的回滚。</p> <h3 id="事务隔离级别和传播机制有什么区别"><a href="#事务隔离级别和传播机制有什么区别" class="header-anchor">#</a> 事务隔离级别和传播机制有什么区别？</h3> <p>事务隔离级别描述的是多个事务同时执行时的某种行为；而事务传播机制是描述，包含了多个事务的方法在相互调用时事务的传播行为。所以事务隔离级别描述的是纵向事务并发调用时的行为模式，而事务传播机制描述的是横向事务传递时的行为模式</p> <h3 id="如何进行统一异常处理"><a href="#如何进行统一异常处理" class="header-anchor">#</a> 如何进行统一异常处理？</h3> <p>在 Spring Boot 中，统一异常处理可以使用 @ControllerAdvice + @ExceptionHandler 来实现，@ControllerAdvice 表示控制器通知类，@ExceptionHandler 是异常处理器，两个结合表示当出现异常的时候执行某个通知，也就是执行某个方法事件，具体实现代码如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">HashMap</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@ControllerAdvice</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ErrorAdive</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">Exception</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
    <span class="token annotation punctuation">@ResponseBody</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span>### map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>###<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;code&quot;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;msg&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>这样写完之后，当项目中有异常时就会触发此方法，返回固定格式的异常信息。</p> <h3 id="java-有几种架构类型"><a href="#java-有几种架构类型" class="header-anchor">#</a> Java 有几种架构类型？</h3> <p>对于 Java 语言来说，它的发展经历了单体架构 -### SOA 面向服务架构 -### 微服务架构。</p> <p><strong>① 单体架构</strong></p> <p>在程序规模不大，开发人员很少的时候，下面的有点是非常显著的：</p> <ol><li>开发简单：单体应用的结构，天然决定了所有代码都集中在一起，开发者不需要在多个应用之间来回跳转来寻找其中的调用逻辑。</li> <li>测试简单：所有代码都在一个应用里，测试人员可以很方便的做到端到端的测试（当然，很多时候测试人员就是开发者自己）。</li> <li>部署简单：因为一个应用就是产品功能的全集，所以在部署的时候，只需要不是一款应用即可。即使是集群部署，也不会增加多少复杂度：只需要将应用部署多份即可。</li> <li>开发迅速。上面的各种简单，带来的就是软件功能可以快速实现。很多时候，实现需求的速度是项目成功与否的决定性因素。</li></ol> <p>所以，在开发简单&amp;独立的产品时，单体架构依然是第一优先选择。</p> <p>但是单体应用随着功能的持续增加、团队规模的不断扩大，我们很快就会发现单体应用的弊端：</p> <ol><li>应用膨胀：所有代码都在一个应用里，导致应用的代码量迅速上升，对于开发者来说，经常需要在海量的代码里找到自己需要维护的哪一行，这种体验往往是令人崩溃的。同时，对于 IDE 来说，一个应用内大量代码也会严重拖慢其运行效率。</li> <li>团队合作冲突：这种冲突会体现在多个方面，在开发阶段，很容易由于修改相同的代码导致代码冲突。部署阶段，又会因为“运行环境里跑的是谁的分支”而造成新的冲突。所有的这些冲突将会严重影响到团队的合作效率。</li> <li>运行效率&amp;稳定性：单体应用，由于逻辑都集中在一起，启动时需要完成所有的初始化工作；同时单一功能的问题也会因为运行在一个进程内，从而导致整个应用宕机。</li></ol> <p><strong>② SOA 框架</strong></p> <p>SOA 是 Service-Oriented Architecture 的简写，直译为“面向服务的架构”，从命名上就可以看出“服务”是 SOA 架构里是非常重要的概念。SOA 的核心思想是“将系统的功能解构为一系列服务”，也就是将之前单体架构分而治之，拆分开来。</p> <p>SOA 会按照业务领域对应用进行粗粒度的垂直拆分，这样一个项目就会变成一些相对独立的应用，但此时，应用间的依赖、调用等相关问题就浮现出来了。</p> <p>SOA 框架的缺点如下：</p> <ol><li>首先就是对 SOA 的解释缺乏统一标准，上文的引用的定义也只是众多解释中使用的较为通用的一种。甚至可以这么说：一千个人眼中，有一千种 SOA 。基于此，很多厂商便借用 SOA 的大旗来推广自己的产品和标准，这又进一步加剧了问题的严重性；</li> <li>高门槛：SOA 对开发人员的要求很高；</li> <li>厂商绑定：由于缺乏统一保准，不同厂商的解决方案之间很难做切换；</li> <li>不适应云环境：在如今的互联网时代，速度就是一切。由此诞生了敏捷开发、持续集成等在不同节点提升业务上线速度的办法。但是方向是不一致的；</li> <li>中心化：虽然应用本身实现了分布式与水平扩展，但是  SOA 需要使用企业服务总线 ESB（Enterprise Service Bus）来实现应用的依赖和调用，但同时 ESB 也成了系统的中枢神经。</li></ol> <p><strong>③ 微服务架构</strong></p> <p>微服务是将一个应用拆分成多个松耦合的服务，这些服务之间通过某种协议（REST、RPC等）进行互相协作，完成原单体架构下的业务功能，但提供更灵活的部署模式，更容易扩展，降低了开发、运维上的复杂度。对于微服务来说，其中一个关键点就是各服务之间的松耦合，各服务之间通过一种“标准”的协议进行沟通，不需要理解对方服务的实现逻辑、实现方式，只要在对方所提供的服务接口没有变化的情况下不会影响自己所提供的服务功能即可。总而言之，微服务核心思路就是分而治之。</p> <h3 id="restful-和-rpc-有什么区别"><a href="#restful-和-rpc-有什么区别" class="header-anchor">#</a> RESTful 和 RPC 有什么区别？</h3> <p>RPC 和 RESTful 都是远程调用接口。</p> <p>RESTful 是一种网络应用程序的设计风格和开发方式，基于 HTTP 协议，可以使用 XML 格式定义或 JSON 格式定义。RESTful 适用于移动互联网厂商作为业务接口的场景，实现第三方调用移动网络资源的功能，动作类型为新增、变更、删除所调用资源。</p> <p>RPC（Remote Procedure Call，远程过程调用）是指计算机程序使过程在不同的地址空间（通常在共享网络的另一台计算机上）执行时，其编码方式就像是正常的（本地）过程调用，而无需程序员明确为远程交互编码细节。RPC是一种服务器-客户端（Client/Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。RPC出现的最初目的，就是为了让计算机能够与调用本地方法一样去调用远程方法。</p> <p>总体来说：RPC 是以一种调用本地方法的思路来调用远程方法，通过各种 RPC 框架隐藏调用远程方法的细节，让用户以为调用的就是本地方法。RPC 隐藏了底层网络通信的复杂度，让我们更专注于业务逻辑的开发。</p> <p>RESTful 通过 HTTP 实现，把用户的需求抽象成对资源的操作，用户必须通过 HTTP 协议的 GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS 七种基本操作去和服务器交互。</p> <p>RPC 通常是服务器和服务器之间的通信，比如和中间件的通信，MQ、分布式缓存、分布式数据库等等。</p> <p>而 REST 通常是面向客户端的（一般是浏览器），他们的使用场景也是不一样的。</p> <h3 id="微服务中的-服务-怎么理解"><a href="#微服务中的-服务-怎么理解" class="header-anchor">#</a> 微服务中的“服务”怎么理解？</h3> <p>微服务中的服务是一个可以独立运行、提供范围有限的功能（可以是业务功能，也有可能是非业务功能）的组件。功能具体实现隐藏在组件内部，而对外则提供访问接口，外部其他服务可以通过这些接口进行访问与交互，从这一方面来说，微服务是可以单独部署运行的。</p> <h3 id="微服务有什么优点"><a href="#微服务有什么优点" class="header-anchor">#</a> 微服务有什么优点？</h3> <p>微服务的设计理念参考了 UNIX 系统，每个微服务仅承担一种职责，并把该职责做到最好。因此，这让我们的应用看起来是一系列服务的集合。微服务架构具有以下优点。</p> <ol><li>可扩展性更强：可以根据每个微服务的性能要求和业务特点来对服务进行灵活扩展，比如通过增加单个服务的集群规模，提升部署了该服务的节点的硬件配置。</li> <li>技术选型更灵活：每个微服务都由不同的团队来维护，所以可以结合业务特性自由选择技术栈。</li> <li>复杂度可控：通过对共享业务服务更细粒度的拆分，一个服务只需要关注一个特定的业务领域，并通过定义良好的接口清晰表述服务边界。由于体积小、复杂度低，开发、维护会更加简单。</li> <li>独立部署：由于每个微服务都是一个独立运行的进程，所以可以实现独立部署。当某个微服务发生变更时不需要重新编译部署整个应用，并且单个微服务的代码量比较小，使得发布更加高效。</li> <li>容错性：在微服务架构中，如果某一个服务发生故障，我们可以使故障隔离在单个服务中。其他服务可以通过重试、降级等机制来实现应用层面的容错。</li></ol> <h3 id="微服务有什么缺点"><a href="#微服务有什么缺点" class="header-anchor">#</a> 微服务有什么缺点？</h3> <p>微服务的缺点有以下几个：</p> <ol><li>故障排查：一次请求可能会经历多个不同的微服务的多次交互，交互的链路可能会比较长，每个微服务会产生自己的日志，在这种情况下如果出现一个故障，开发人员定位问题的根源会比较困难。</li> <li>分布式架构的复杂性：微服务本身构建的是一个分布式系统，分布式系统涉及服务之间的远程通信，而网络通信中网络的延迟和网络故障是无法避免的，从而增加了应用程序的复杂度。</li> <li>服务监控：在一个单体架构中很容易实现服务的监控，因为所有的功能都在一个服务中。在微服务架构中，服务监控开销会非常大，可以想象一下，在几百个微服务组成的架构中，我们不仅要对整个链路进行监控，还需要对每一个微服务都实现一套类似单体架构的监控。</li> <li>运维成本：在微服务中，需要保证几百个微服务的正常运行，对于运维的挑战是巨大的。比如单个服务流量激增时如何快速扩容、服务拆分之后导致故障点增多如何处理、如何快速部署和统一管理众多的服务等。</li> <li>服务依赖：微服务数量增加之后，各个服务之间会存在更多的依赖关系，使得系统整体更为复杂。假设你在完成一个案例，需要修改服务A、B、C，而A依赖B，B依赖C。在单体式应用中，你只需要改变相关模块，整合变化，再部署就好了。对比之下，微服务架构模式就需要考虑相关改变对不同服务的影响。比如，你需要更新服务C，然后是B，最后才是A，幸运的是，许多改变一般只影响一个服务，需要协调多服务的改变很少。</li> <li>学习成本更大：微服务架构虽然可以将业务分解为更小、更容易开发的模式，但是也需要开发人员学习掌握一系列的微服务开发技术，加大了进入门槛，这也是非常有难度的一个挑战。</li></ol> <h3 id="微服务中有哪些组件"><a href="#微服务中有哪些组件" class="header-anchor">#</a> 微服务中有哪些组件？</h3> <p>微服务中的重要组件有以下几个。</p> <ol><li>服务注册与发现</li> <li>配置中心</li> <li>网关</li> <li>负载均衡</li> <li>熔断限流</li> <li>链路监控</li></ol> <h3 id="微服务和-spring-cloud-有什么关系"><a href="#微服务和-spring-cloud-有什么关系" class="header-anchor">#</a> 微服务和 Spring Cloud 有什么关系？</h3> <p>很多人认为微服务就是 Spring Cloud，Spring Cloud 就等于微服务，但严格意义上来说，微服务和 Spring Cloud 之间是不能直接划上等号的。微服务是一种架构和项目实现思想，而 Spring Cloud 是一套技术解决方案。比如在 Spring Cloud 出现之前，各个微服务之间的调用是非常痛苦的事，虽然市面上有很多开源的 RPC（Remote Procedure Call，远程调用）框架，如 Thrift、Dubbo、Motan、gRPC 等，但如何做好服务的动态感知就是一个非常复杂的事，比如 A 服务要调用 B 服务，但是 B 服务部署了 10 个节点，那么 A 服务如何动态维护 B 服务的 10 个不同的地址信息呢？直到 Spring Cloud 的出现，便解决了这些难题。所以可以认为 Spring Cloud 为微服务提供了一种优秀的解决方案。</p> <h3 id="什么是-spring-cloud"><a href="#什么是-spring-cloud" class="header-anchor">#</a> 什么是 Spring Cloud？</h3> <p>Spring Cloud 是 Pivotal 公司在 2015 年发布的一个项目，当然，Spring 和 Spring Boot 也是 Pivotal 公司发布的产品。Spring Cloud 提供了一些可以让开发者快速构建微服务应用的工具，比如配置管理、服务发现、熔断、智能路由等，这些服务可以在任何分布式环境下很好地工作。Spring Cloud 主要致力于解决如下问题：</p> <ol><li>Distributed/versioned configuration：分布式及版化配置；</li> <li>Service registration and discovery：服务注册与发现；</li> <li>Routing：服务路由；</li> <li>Service-to-service calls：服务调用；</li> <li>Load balancing：负载均衡；</li> <li>Circuit Breakers：断路器；</li> <li>Global locks：全局锁；</li> <li>Leadership election and cluster state：Leader 选举及集群状态；</li> <li>Distributed messaging：分布式消息。</li></ol> <p>需要注意的是，Spring Cloud 并不是 Spring 团队全新研发的框架，它只是把一些比较优秀的解决微服务架构中常见问题的开源框架基于 Spring Cloud 规范进行了整合，通过 Spring Boot 这个框架进行再次封装后屏蔽掉了复杂的配置，给开发者提供良好的开箱即用的微服务开发体验。所以，Spring Cloud 其实就是一套规范，而 Spring Cloud Netflix、Spring Cloud Alibaba 才是 Spring Cloud 规范的实现。</p> <h3 id="spring-boot-和-spring-cloud-有什么区别"><a href="#spring-boot-和-spring-cloud-有什么区别" class="header-anchor">#</a> Spring Boot 和 Spring Cloud 有什么区别？</h3> <p>它们的区别有以下几个：</p> <ol><li>Spring Boot 专注于快速方便的开发单个个体微服务。</li> <li>Spring Cloud 是关注全局的微服务协调整理治理框架，它将 Spring Boot 开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。</li> <li>Spring Boot 可以离开 Spring Cloud 独立使用开发项目， 但是 Spring Cloud 离不开 Spring Boot。Spring Cloud 项目都是基于 Spring Boot 创建的，所以 Spring Cloud 需要依赖 Spring Boot。</li> <li>Spring Boot 专注于快速、方便的开发单个微服务个体，Spring Cloud 关注全局的服务治理框架。</li></ol> <h3 id="spring-cloud-和-dubbo-有什么区别"><a href="#spring-cloud-和-dubbo-有什么区别" class="header-anchor">#</a> Spring Cloud 和 Dubbo 有什么区别？</h3> <p>Spring Cloud 提供了一些可以让开发者快速构建微服务应用的工具，比如配置管理、服务发现、熔断、智能路由等，这些服务可以在任何分布式环境下很好地工作。而 Dubbo 是一款微服务框架，为大规模微服务实践提供高性能 RPC 通信、流量治理、可观测性等解决方案，涵盖 Java、Golang 等多种语言 SDK 实现。</p> <p>它们最大区别的是 Spring Cloud 抛弃了 Dubbo 的 RPC 通信，采用的是基于 HTTP 的 RESTFul 方式请求。但 Dubbo 的通讯性能更高，而 Spring Cloud 提供的功能更全。</p> <h3 id="什么是-spring-cloud-netflix"><a href="#什么是-spring-cloud-netflix" class="header-anchor">#</a> 什么是 Spring Cloud Netflix？</h3> <p>Spring Cloud Netflix 是 Netflix（美国奈飞公司）提供的 Spring Cloud 规范的具体实现框架，它提供了以下组件：</p> <ol><li>Eureka：服务注册与发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便的查看所有注册的服务的界面。 所有的服务使用 Eureka 的服务发现客户端来将自己注册到 Eureka 的服务器上；</li> <li>Zuul：服务网关，所有的客户端请求通过这个网关访问后台的服务。他可以使用一定的路由配置来判断某一个 URL 由哪个服务来处理。并从 Eureka 获取注册的服务来转发请求；</li> <li>Ribbon：负载均衡，Zuul 网关将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过 Ribbon 来通过一定的负载均衡策略来发送给某一个服务实例；</li> <li>Feign：远程服务的客户端代理，服务之间如果需要相互访问，可以使用 RestTemplate，也可以使用Feign客户端访问。它默认会使用 Ribbon 来实现负载均衡；</li> <li>Hystrix：断路器，提供服务熔断和限流功能，我们只需要在服务接口上添加 Hystrix 标签，就可以实现对这个接口的监控和断路器功能；</li> <li>Hystrix Dashboard：监控面板，监控和断路器。我们只需要在服务接口上添加Hystrix标签，就可以实现对这个接口的监控和断路器功能；</li> <li>Turbine：将各个服务实例上的 Hystrix 监控信息进行统一聚合，使用 Hystrix 监控，我们需要打开每一个服务实例的监控信息来查看。而 Turbine 可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。</li></ol> <p>Netflix 本身是一套非常好的组件，由于 Netflix 对 Zuul 1、Ribbon、Archaius 等组件的维护不利，Spring Cloud 决定在 Greenwich 中将如下项目都改为“维护模式”（进入维护模式意味着这些组件以后不会有大的功能更新，只会修复 Block 级别的 Bug 及安全问题）。当然，这些组件短期来说仍然可以继续使用，但是长期来看显然是不合适的。</p> <p>不过我们也不用太担心这个问题，因为 Spring 官方提供了替换方案，如新发布的 Spring Cloud Alibaba 就是一个不错的替代 Spring Cloud Netflix 的组件。</p> <h3 id="eureka-和-zookeeper-有什么区别"><a href="#eureka-和-zookeeper-有什么区别" class="header-anchor">#</a> Eureka 和 ZooKeeper 有什么区别？</h3> <p>从功能上来说 Eureka 和 ZooKeeper都可以实现服务注册与发现，但它们主要有以下四点区别。</p> <p>① ZooKeeper 保证的是 CP 而 Eureka 保证的是 AP</p> <p>CAP 含义如下：</p> <ol><li>C：Consisteny（一致性），比如数据库是主从模式，一个写库请求进来了，主库完成了写入操作，但是再（从库）同步数据之前，另一个用户查了这条数据，结果没查到，但是也没报错，这就不是强一致性。虽然最终会同步成功，但这是最终一致性的体现。强一致性的体现在于我不管你因为什么没同步成功（可能网络延迟或其他等），只要没同步成功，我这个从库就不能对外提供服务。必须主从数据一致才可以提供服务。</li> <li>A：Availability（可用性），还是上面的例子，就是保证了可用性。因为虽然主从没同步完成，但是我从库照样能提供服务而且及时响应结果。也就是说可用性保证服务可用，而不在乎数据是否一致。</li> <li>P：Partition Tolerance（分区容错性），集群部署了三台服务，挂了一台，其他两台还能继续对外提供服务，这时候我就认为他是没问题的，也就是我能容忍你挂了一台，只要还有服务能对外提供请求即可。所以一般分区容忍性是必须的，一般都需要从 C 和 A 之间做选择。</li></ol> <p>所以 CP 模式既一致性和分区容忍性，而 AP 模式即可用性和分区容忍性。</p> <p>ZooKeeper 在选举期间注册服务瘫痪，虽然服务最终会恢复，但是选举期间不可用的；Eureka 各个节点是平等关系，只要有一台 Eureka 就可以保证服务可用，而查询到的数据并不是最新的。</p> <p>② ZooKeeper 有 Leader 和 Follower 角色之分，而 Eureka 各个节点平等。</p> <p>③ ZooKeeper 采用过半数存活原则，Eureka 采用自我保护机制解决分区问题。</p> <h3 id="什么是-eureka-的自我保护机制"><a href="#什么是-eureka-的自我保护机制" class="header-anchor">#</a> 什么是 Eureka 的自我保护机制?</h3> <p>当Eureka Server 节点在短时间内丢失了过多实例的连接时，比如网络故障或频繁启动关闭客户端时，节点会进入自我保护模式，保护注册信息，不再删除注册数据。故障恢复时，才会自动退出自我保护模式。</p> <h3 id="spring-cloud-alibaba-提供了什么功能"><a href="#spring-cloud-alibaba-提供了什么功能" class="header-anchor">#</a> Spring Cloud Alibaba 提供了什么功能？</h3> <p>Spring Cloud Alibaba 2018 年正式入驻 Spring Cloud 官方孵化器，并发布了第一个预览版本。2019 年 8 月在 Alibaba 仓库发布第一个毕业版本。它提供的主要功能有以下几个：</p> <ol><li>服务限流降级：默认支持 WebServlet、WebFlux、OpenFeign、RestTemplate、Spring Cloud Gateway、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控。</li> <li>服务注册与发现：适配 Spring Cloud 服务注册与发现标准，默认集成了 Ribbon 的支持。</li> <li>分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新。</li> <li>消息驱动能力：基于 Spring Cloud Stream 为微服务应用构建消息驱动能力。</li> <li>分布式事务：使用 @GlobalTransactional 注解， 高效并且对业务零侵入地解决分布式事务问题。</li> <li>阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li> <li>分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行。</li> <li>阿里云短信服务：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ol> <h3 id="spring-cloud-alibaba-有哪些组件"><a href="#spring-cloud-alibaba-有哪些组件" class="header-anchor">#</a> Spring Cloud Alibaba 有哪些组件？</h3> <p>它提供的重要组件有以下几个：</p> <ol><li>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li> <li>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li> <li>RocketMQ：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li> <li>Seata：一个易于使用的高性能微服务分布式事务解决方案。</li> <li>Alibaba Cloud OSS：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li> <li>Dubbo：提供高性能 RPC 通信、流量治理、可观测性等解决方案，它涵盖 Java、Golang 等多种语言 SDK 实现。</li> <li>Alibaba Cloud SchedulerX：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li> <li>Alibaba Cloud SMS：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ol> <h3 id="什么是服务注册和服务发现"><a href="#什么是服务注册和服务发现" class="header-anchor">#</a> 什么是服务注册和服务发现？</h3> <p>服务注册和发现的意思是服务进程在注册中心注册自己的位置，客户端应用进程向注册中心发起查询，来获取服务的位置，服务发现的一个重要作用就是提供一个可用的服务列表。</p> <ol><li>服务注册：服务进程在注册中心注册自己的位置。它通常注册自己的主机和端口号，有时还有身份验证信息，协议，版本号，以及运行环境的详细资料。</li> <li>服务发现：客户端应用进程向注册中心发起查询，来获取服务的位置。服务发现的一个重要作用就是提供一个可用的服务列表。</li></ol> <h3 id="服务发现有几种模式"><a href="#服务发现有几种模式" class="header-anchor">#</a> 服务发现有几种模式？</h3> <p>服务发现主要有两种发现模式：客户端发现和服务端发现。</p> <ol><li>客户端发现模式要求客户端负责查询注册中心，获取服务提供者的列表信息，使用负载均衡算法选择一个合适的服务提供者，发送请求。</li> <li>服务端发现模式，客户端每次都请求注册中心，由注册中心内部选择一个合适的服务提供者，并将请求转发至该服务提供者，需要注意的是当一个请求过来的时候，注册中心内部获取服务提供者列表和使用负载均衡算法。</li></ol> <h3 id="这两种服务发现模式有什么区别"><a href="#这两种服务发现模式有什么区别" class="header-anchor">#</a> 这两种服务发现模式有什么区别？</h3> <p>客户端服务发现和服务器端服务发现的区别如下。</p> <p><strong>① 客户端服务发现</strong></p> <p>在客户端模式下，如果要进行微服务调用，首先要进行的是到服务注册中心获取服务列表，然后再根据调用端本地的负载均衡策略，进行服务调用。</p> <p>在上图中，client 端提供了负载均衡的功能，其首先从注册中心获取服务提供者的列表，然后通过自身负载均衡算法，选择一个最合理的服务提供者进行调用：</p> <ol><li>服务提供者向注册中心进行注册，提交自己的相关信息。</li> <li>服务消费者定期从注册中心获取服务提供者列表。</li> <li>服务消费者通过自身的负载均衡算法，在服务提供者列表里面选择一个合适的服务提供者进行访问。</li></ol> <p>客户端服务发现的优点：</p> <ol><li>负载均衡作为client中一个功能，用自身的算法，从服务提供者列表中选择一个合适服务提供者进行访问，因此client端可以定制化负载均衡算法。优点是服务客户端可以灵活、智能地制定负载均衡策略，包括轮询、加权轮询、一致性哈希等策略。</li> <li>可以实现点对点的网状通讯，即去中心化的通讯。可以有效避开单点造成的性能瓶颈和可靠性下降等问题。</li> <li>服务客户端通常以SDK的方式直接引入到项目，这种方式语言的整合程度最佳，程序执行性能最佳，程序错误排查更加容易。</li></ol> <p>客户端服务发现的缺点：</p> <ol><li>当负载均衡算法需要更新时候，很难做到同一时间全部更新，所以就造成新旧算法同时运行</li> <li>与注册中心紧密耦合，如果要换注册中心，需要去修改代码，重新上线。微服务的规模越大，服务更新越困难，这在一定程度上违背了微服务架构提倡的技术独立性。</li></ol> <p><strong>② 服务器端服务发现</strong></p> <p>在服务端模式下，调用方直接向服务注册中心进行请求，服务注册中心再通过自身负载均衡策略，对微服务进行调用。这个模式下，调用方不需要在自身节点维护服务发现逻辑以及服务注册信息。</p> <p>在服务端模式下：</p> <ol><li>服务提供者向注册中心进行服务注册。</li> <li>注册中心提供负载均衡功能。</li> <li>服务消费者去请求注册中心，由注册中心根据服务提供列表的健康情况，选择合适的服务提供者供服务消费者调用。</li></ol> <p>现代容器化部署平台（如 Docker 和 Kubernetes）就是服务端服务发现模式的一个例子，这些部署平台都具有内置的服务注册表和服务发现机制。容器化部署平台为每个服务提供路由请求的能力。服务客户端向路由器（或者负载均衡器）发出请求，容器化部署平台自动将请求路由到目标服务一个可用的服务实例。因此，服务注册，服务发现和请求路由完全由容器化部署平台处理。</p> <p>服务端发现模式的优点：</p> <ol><li>服务消费者不需要关心服务提供者的列表，以及其采取何种负载均衡策略。</li> <li>负载均衡策略的改变，只需要注册中心修改就行，不会出现新老算法同时存在的现象。</li> <li>服务提供者上下线，对于服务消费者来说无感知。</li></ol> <p>服务端发现模式的缺点：</p> <ol><li>运行时间增加，因为每次请求都要请求注册中心，由其返回一个服务提供者。</li> <li>注册中心成为瓶颈，所有的请求都要经过注册中心，如果注册服务过多，服务消费者流量过大，可能会导致注册中心不可用。</li> <li>微服务的一个目标是故障隔离，将整个系统切割为多个服务共同运行，如果某服务无法正常运行，只会影响到整个系统的相关部分功能，其它功能能够正常运行，即去中心化。然而，服务端发现模式实际上是集中式的做法，如果路由器或者负载均衡器无法提供服务，那么将导致整个系统瘫痪。</li></ol> <p>目前来说，大部分服务发现的实现都采取了客户端模式（sofapbrpc、brpc等）。但这个世界没有完美的架构和模式，不同的场景都有适合的解决方案。我们在调研决策的时候，一定要根据实际情况去权衡对比，选择最适合当前阶段的方案，然后通过渐进迭代的方式不断完善优化方案。</p> <h3 id="问题-服务注册有几种方式"><a href="#问题-服务注册有几种方式" class="header-anchor">#</a> 问题：服务注册有几种方式？</h3> <p>服务注册大致分为两类：</p> <ol><li>自注册模式：自注册，顾名思义，就是上述这些动作，有服务(client)本身来维护。每个服务启动后，需要到统一的服务注册中心进行注册登记，服务正常终止后，也可以到注册中心移除自身的注册记录。在服务执行过程中，通过不断的发送心跳信息，来通知注册中心，本服务运行正常。注册中心只要超过一定的时间没有收到心跳消息，就可以将这个服务状态判断为异常，进而移除该服务的注册记录。</li> <li>三方注册模式：这个模式与自注册模式相比，区别就是健康检查的动作不是有服务本身(client)来负责，而是由其它第三方服务来确认。有时候服务自身发送心跳信息的方式并不精确，因为可能服务本身已经存在故障，某些接口功能不可用，但仍然可以不断的发送心跳信息，导致注册中心没有发觉该服务已经异常，从而源源不断的将流量打到已经异常的服务上来。这时候，要确认服务是否正常运转的健康检查机制，就不能只依靠心跳，必须通过其它第三方的验证(ping)，不断的从外部来确认服务本身的健康状态。</li></ol> <h3 id="什么是负载均衡"><a href="#什么是负载均衡" class="header-anchor">#</a> 什么是负载均衡？</h3> <p>负载均衡（Load Balance，简称 LB）是高并发、高可用系统必不可少的关键组件，目标是尽力将网络流量平均分发到多个服务器上，以提高系统整体的响应速度和可用性。</p> <p>负载均衡的主要作用如下：</p> <ol><li>高并发：负载均衡通过算法调整负载，尽力均匀的分配应用集群中各节点的工作量，以此提高应用集群的并发处理能力（吞吐量）。</li> <li>伸缩性：添加或减少服务器数量，然后由负载均衡进行分发控制。这使得应用集群具备伸缩性。</li> <li>高可用：负载均衡器可以监控候选服务器，当服务器不可用时，自动跳过，将请求分发给可用的服务器。这使得应用集群具备高可用的特性。</li> <li>安全防护：有些负载均衡软件或硬件提供了安全性功能，如：黑白名单处理、防火墙，防 DDos 攻击等。</li></ol> <h3 id="负载均衡有几种类型"><a href="#负载均衡有几种类型" class="header-anchor">#</a> 负载均衡有几种类型？</h3> <p>负载均衡从硬件的层面可分为：硬件负载均衡和软件负载均衡。同时负载均衡从服务器的类型上又可分为：服务器负载均衡和客户端负载均衡。</p> <p><strong>① 硬件负载均衡</strong></p> <p>硬件负载均衡，一般是在定制处理器上运行的独立负载均衡服务器，价格昂贵，土豪专属。硬件负载均衡的主流产品有：F5 和 A10。</p> <p>硬件负载均衡的优点：</p> <ol><li>功能强大：支持全局负载均衡并提供较全面的、复杂的负载均衡算法。</li> <li>性能强悍：硬件负载均衡由于是在专用处理器上运行，因此吞吐量大，可支持单机百万以上的并发。</li> <li>安全性高：往往具备防火墙，防 DDos 攻击等安全功能。</li></ol> <p>硬件负载均衡的缺点：</p> <ol><li>成本昂贵：购买和维护硬件负载均衡的成本都很高。</li> <li>扩展性差：当访问量突增时，超过限度不能动态扩容。</li></ol> <p><strong>② 软件负载均衡</strong></p> <p>软件负载均衡，应用最广泛，无论大公司还是小公司都会使用。软件负载均衡从软件层面实现负载均衡，一般可以在任何标准物理设备上运行。</p> <p>软件负载均衡的主流产品有：Nginx、HAProxy、LVS（Linux Virtual Server）。</p> <p>软件负载均衡的优点：</p> <ol><li>扩展性好：适应动态变化，可以通过添加软件负载均衡实例，动态扩展到超出初始容量的能力。</li> <li>成本低廉：软件负载均衡可以在任何标准物理设备上运行，降低了购买和运维的成本。</li></ol> <p>软件负载均衡的缺点：</p> <ol><li>性能略差：相比于硬件负载均衡，软件负载均衡的性能要略低一些。</li></ol> <p><strong>③ 服务端负载均衡</strong></p> <p>服务端负载均衡是指服务器端存储了所有可以调用服务的列表（通过心跳机制保证服务的可用性），然后客户端先访问负载均衡的服务器，服务器再通过负载均衡策略将请求转发到真正处理客户端服务的地址。</p> <p>比如 Nginx 和 F5 都可以划分到服务端的负载均衡里面，后端的服务器地址列表是存储在后端服务器中或者存在专门的 Nginx 服务器或 F5 上。服务器的地址列表的来源是通过注册中心或者手动配置的方式来的。</p> <p><strong>④ 客户端负载均衡</strong></p> <p>客户端负载均衡是客户端自己维护了一份服务器的地址列表，再有客户端自己通过负载均衡策略来实现服务的调用，比如 Ribbon 就是客户端负载均衡框架。</p> <p>客户端负载均衡器一般的实现原理是通过注册中心，如 Nacos，将可用的服务列表拉取到本地（客户端），再通过客户端负载均衡器（设置的负载均衡策略）获取到某个服务器的具体 IP 和端口，然后再通过 HTTP 框架请求服务并得到结果。</p> <h3 id="服务端负载均衡和客户端负载均衡有什么区别"><a href="#服务端负载均衡和客户端负载均衡有什么区别" class="header-anchor">#</a> 服务端负载均衡和客户端负载均衡有什么区别？</h3> <p>它们的区别主要体现在以下 2 点：</p> <ol><li>灵活性：服务器端负载均衡器是由运维人员把控和修改的，而客户端负载均衡是由开发团队灵活配置和修改的，并且服务器端的负载均衡策略只能所有调用者公用一套，而客户端负载均衡器可以设置多套，所以客户端负载均衡器更加灵活。</li> <li>依赖注册中心：客户端负载均衡需要强依赖注册中心，通过注册中心来获取可用的服务列表，而服务器端负载均衡器则不需要依赖注册中心。</li></ol> <p>目前微服务框架使用的是客户端负载均衡器，而传统软件如 Nginx、F5 等使用的是服务器负载均衡器。</p> <h3 id="ribbon-有哪些负载均衡策略"><a href="#ribbon-有哪些负载均衡策略" class="header-anchor">#</a> Ribbon 有哪些负载均衡策略？</h3> <p>Ribbon 内置了以下 7 种负载均衡策略。</p> <p><strong>1.轮询策略</strong></p> <p>轮询策略：RoundRobinRule，按照一定的顺序依次调用服务实例。比如一共有 3 个服务，第一次调用服务 1，第二次调用服务 2，第三次调用服务3，依次类推。</p> <p>此策略的配置设置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">springcloud-nacos-provider</span><span class="token punctuation">:</span> <span class="token comment"># nacos中的服务id</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RoundRobinRule <span class="token comment">#设置负载均衡</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>2.权重策略</strong></p> <p>权重策略：WeightedResponseTimeRule，根据每个服务提供者的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性也就越低。</p> <p>它的实现原理是，刚开始使用轮询策略并开启一个计时器，每一段时间收集一次所有服务提供者的平均响应时间，然后再给每个服务提供者附上一个权重，权重越高被选中的概率也越大。</p> <p>此策略的配置设置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">springcloud-nacos-provider</span><span class="token punctuation">:</span> <span class="token comment"># nacos中的服务id</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.WeightedResponseTimeRule
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>3.随机策略</strong></p> <p>随机策略：RandomRule，从服务提供者的列表中随机选择一个服务实例。</p> <p>此策略的配置设置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">springcloud-nacos-provider</span><span class="token punctuation">:</span> <span class="token comment"># nacos中的服务id</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment">#设置负载均衡</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>4.最小连接数策略</strong></p> <p>最小连接数策略：BestAvailableRule，也叫最小并发数策略，它是遍历服务提供者列表，选取连接数最小的⼀个服务实例。如果有相同的最小连接数，那么会调用轮询策略进行选取。</p> <p>此策略的配置设置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">springcloud-nacos-provider</span><span class="token punctuation">:</span> <span class="token comment"># nacos中的服务id</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.BestAvailableRule <span class="token comment">#设置负载均衡</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>5.重试策略</strong></p> <p>重试策略：RetryRule，按照轮询策略来获取服务，如果获取的服务实例为 null 或已经失效，则在指定的时间之内不断地进行重试来获取服务，如果超过指定时间依然没获取到服务实例则返回 null。</p> <p>此策略的配置设置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">ConnectTimeout</span><span class="token punctuation">:</span> <span class="token number">2000</span> <span class="token comment"># 请求连接的超时时间</span>
  <span class="token key atrule">ReadTimeout</span><span class="token punctuation">:</span> <span class="token number">5000</span> <span class="token comment"># 请求处理的超时时间</span>
<span class="token key atrule">springcloud-nacos-provider</span><span class="token punctuation">:</span> <span class="token comment"># nacos 中的服务 id</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment">#设置负载均衡</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>6.可用性敏感策略</strong></p> <p>可用敏感性策略：AvailabilityFilteringRule，先过滤掉非健康的服务实例，然后再选择连接数较小的服务实例。</p> <p>此策略的配置设置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">springcloud-nacos-provider</span><span class="token punctuation">:</span> <span class="token comment"># nacos中的服务id</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.AvailabilityFilteringRule
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>7.区域敏感策略</strong></p> <p>区域敏感策略：ZoneAvoidanceRule，根据服务所在区域（zone）的性能和服务的可用性来选择服务实例，在没有区域的环境下，该策略和轮询策略类似。</p> <p>此策略的配置设置如下：</p> <div class="language-yaml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">springcloud-nacos-provider</span><span class="token punctuation">:</span> <span class="token comment"># nacos中的服务id</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.ZoneAvoidanceRule
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="说一下什么是限流"><a href="#说一下什么是限流" class="header-anchor">#</a> 说一下什么是限流？</h3> <p>限流就是限制流量的意思，它是一种保护系统正常运行的机制。常见的限流场景有：</p> <ol><li>限制某个接口一分钟内最多请求 100 次</li> <li>限制某个用户的下载速度最多 100KB/S</li> <li>限制某个用户同时只能对某个接口发起 5 路请求</li> <li>限制某个 IP 来源禁止访问任何请求</li></ol> <p>从上面的场景可以看出，根据不同的请求者和请求资源，可以组合出不同的限流规则。可以根据请求者的 IP 来进行限流，或者根据请求对应的用户来限流，又或者根据某个特定的请求参数来限流。而限流的对象可以是请求的频率，传输的速率，或者并发量等，其中最常见的两个限流对象是请求频率和并发量，他们对应的限流被称为请求频率限流（Request rate limiting）和并发量限流（Concurrent requests limiting）。</p> <p>比如 Sentinel 中就提供了两种限流机制：QPS（每秒查询数）限流和并发数限流，其实对应的就是请求频次限流和并发量限流。</p> <h3 id="限流的处理方式有哪些"><a href="#限流的处理方式有哪些" class="header-anchor">#</a> 限流的处理方式有哪些？</h3> <p>常见的限流处理方式有以下 3 种：</p> <ol><li>拒绝服务</li> <li>排队等待</li> <li>服务降级</li></ol> <p>最简单的做法是拒绝服务，直接抛出异常，返回错误信息（比如返回 HTTP 状态码 429 Too Many Requests），或者给前端返回 302 重定向到一个错误页面，提示用户资源没有了或稍后再试。但是对于一些比较重要的接口不能直接拒绝，比如秒杀、下单等接口，我们既不希望用户请求太快，也不希望请求失败，这种情况一般会将请求放到一个消息队列中排队等待，消息队列可以起到削峰和限流的作用。第三种处理方式是服务降级，当触发限流条件时，直接返回兜底数据，比如查询商品库存的接口，可以默认返回有货。</p> <h3 id="限流实现算法有哪些"><a href="#限流实现算法有哪些" class="header-anchor">#</a> 限流实现算法有哪些？</h3> <p>限流的常见算法有：</p> <ol><li>固定窗口算法（Fixed Window）</li> <li>滑动窗口算法（Rolling Window 或 Sliding Window）</li> <li>漏桶算法（Leaky Bucket）</li> <li>令牌桶算法（Token Bucket）</li></ol> <p><strong>① 固定窗口算法（Fixed Window）</strong></p> <p>固定窗口算法是一种最简单的限流算法，它根据限流的条件，将请求时间映射到一个时间窗口，再使用计数器累加访问次数。譬如限流条件为每分钟 5 次，那么就按照分钟为单位映射时间窗口，假设一个请求时间为 11:00:45，时间窗口就是 11:00:00 ~ 11:00:59，在这个时间窗口内设定一个计数器，每来一个请求计数器加一，当这个时间窗口的计数器超过 5 时，就触发限流条件。当请求时间落在下一个时间窗口内时（11:01:00 ~ 11:01:59），上一个窗口的计数器失效，当前的计数器清零，重新开始计数。</p> <p>计数器算法非常容易实现，在单机场景下可以使用 AtomicLong、LongAdder 或 Semaphore 来实现计数，而在分布式场景下可以通过 Redis 的 INCR 和 EXPIRE 等命令并结合 EVAL 或 lua 脚本来实现，Redis 官网提供了几种简单的实现方式。无论是请求频率限流还是并发量限流都可以使用这个算法。</p> <p>不过这个算法的缺陷也比较明显，那就是存在严重的临界问题。由于每过一个时间窗口，计数器就会清零，这使得限流效果不够平滑，恶意用户可以利用这个特点绕过我们的限流规则。</p> <p><strong>② 滑动窗口算法（Rolling Window 或 Sliding Window）</strong></p> <p>为了解决固定窗口算法的临界问题，可以将时间窗口划分成更小的时间窗口，然后随着时间的滑动删除相应的小窗口，而不是直接滑过一个大窗口，这就是滑动窗口算法。我们为每个小时间窗口都设置一个计数器，大时间窗口的总请求次数就是每个小时间窗口的计数器的和。如下图所示，我们的时间窗口是 5 秒，可以按秒进行划分，将其划分成 5 个小窗口，时间每过一秒，时间窗口就滑过一秒。</p> <p>每次处理请求时，都需要计算所有小时间窗口的计数器的和，考虑到性能问题，划分的小时间窗口不宜过多，譬如限流条件是每小时 N 个，可以按分钟划分为 60 个窗口，而不是按秒划分成 3600 个。当然如果不考虑性能问题，划分粒度越细，限流效果就越平滑。相反，如果划分粒度越粗，限流效果就越不精确，出现临界问题的可能性也就越大，当划分粒度为 1 时，滑动窗口算法就退化成了固定窗口算法。由于这两种算法都使用了计数器，所以也被称为计数器算法（Counters）。</p> <p><strong>③ 漏桶算法（Leaky Bucket）</strong></p> <p>除了计数器算法，另一个很自然的限流思路是将所有的请求缓存到一个队列中，然后按某个固定的速度慢慢处理，这其实就是漏桶算法（Leaky Bucket）。漏桶算法假设将请求装到一个桶中，桶的容量为 M，当桶满时，请求被丢弃。在桶的底部有一个洞，桶中的请求像水一样按固定的速度（每秒 r 个）漏出来。</p> <p>桶的上面是个水龙头，我们的请求从水龙头流到桶中，水龙头流出的水速不定，有时快有时慢，这种忽快忽慢的流量叫做 Bursty flow。如果桶中的水满了，多余的水就会溢出去，相当于请求被丢弃。从桶底部漏出的水速是固定不变的，可以看出漏桶算法可以平滑请求的速率。</p> <p>当请求到达时，不直接处理请求，而是将其放入一个队列，然后另一个线程以固定的速率从队列中读取请求并处理，从而达到限流的目的。注意的是这个队列可以有不同的实现方式，比如设置请求的存活时间，或将队列改造成 PriorityQueue，根据请求的优先级排序而不是先进先出。当然队列也有满的时候，如果队列已经满了，那么请求只能被丢弃了。漏桶算法有一个缺陷，在处理突发流量时效率很低，于是人们又想出了下面的令牌桶算法。</p> <p><strong>④ 令牌桶算法（Token Bucket）</strong></p> <p>令牌桶算法（Token Bucket）是目前应用最广泛的一种限流算法，它的基本思想由两部分组成：生成令牌和消费令牌。</p> <ol><li>生成令牌：假设有一个装令牌的桶，最多能装 M 个，然后按某个固定的速度（每秒 r 个）往桶中放入令牌，桶满时不再放入；</li> <li>消费令牌：我们的每次请求都需要从桶中拿一个令牌才能放行，当桶中没有令牌时即触发限流，这时可以将请求放入一个缓冲队列中排队等待，或者直接拒绝。</li></ol> <p>在上面的图中，我们将请求放在一个缓冲队列中，可以看出这一部分的逻辑和漏桶算法几乎一模一样，只不过在处理请求上，一个是以固定速率处理，一个是从桶中获取令牌后才处理。</p> <h3 id="什么是-sentinel"><a href="#什么是-sentinel" class="header-anchor">#</a> 什么是 Sentinel？</h3> <p>Sentinel 是面向分布式、多语言异构化服务架构的流量治理组件，主要以流量为切入点，从流量路由、流量控制、流量整形、熔断降级、系统自适应过载保护、热点流量防护等多个维度来帮助开发者保障微服务的稳定性。</p> <h3 id="sentinel-提供了哪些功能"><a href="#sentinel-提供了哪些功能" class="header-anchor">#</a> Sentinel 提供了哪些功能？</h3> <p>Sentinel 提供的主要功能有：</p> <ol><li>流量控制：流量控制主要指的是限流功能，当有突发流量时，通过限流可以防止程序繁忙甚至是挂掉的问题；</li> <li>熔断降级：指程序在出现问题时，仍能保证有限功能可用的一种机制；</li> <li>系统负载保护：当操作系统的某项指标，比如 CPU 使用率达到某个值之后，拒绝部分请求以实现保护系统的目的。</li></ol> <h3 id="sentinel-有什么优点"><a href="#sentinel-有什么优点" class="header-anchor">#</a> Sentinel 有什么优点？</h3> <p>Sentinel 的优点主要有以下几个：</p> <ol><li>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、实时熔断下游不可用应用等。</li> <li>完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li> <li>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li> <li>完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。例如定制规则管理、适配数据源等。</li></ol> <h3 id="sentinel-有哪些核心组件"><a href="#sentinel-有哪些核心组件" class="header-anchor">#</a> Sentinel 有哪些核心组件？</h3> <p>Sentinel 的核心组件分为两部分：</p> <ol><li>核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li> <li>控制台（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。</li></ol> <h3 id="sentinel-是如何运作的"><a href="#sentinel-是如何运作的" class="header-anchor">#</a> Sentinel 是如何运作的？</h3> <p>要了解 Sentinel 是如何运作的，需要先了解 Sentinel 中的两个基本概念：</p> <ol><li>资源：资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源；</li> <li>规则：围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</li></ol> <p>Sentinel 把（每个）接口视为资源，再通过配置的规则来控制资源的行为，如限流、熔断等行为。</p> <h3 id="什么是-nacos"><a href="#什么是-nacos" class="header-anchor">#</a> 什么是 Nacos？</h3> <p>Nacos 是 Dynamic Naming and Configuration Service 首字母缩写，它致力于帮助开发者发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。同时它也是 Spring Cloud Alibaba 中的重要组件。</p> <h3 id="nacos-提供了哪些功能"><a href="#nacos-提供了哪些功能" class="header-anchor">#</a> Nacos 提供了哪些功能？</h3> <p>Nacos 提供了以下几个重要的功能：</p> <ol><li><strong>服务发现和服务健康监测</strong>：Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用原生 DK、OpenAPI、或一个独立的 Agent TODO 注册 Service 后，服务消费者可以使用 DNS TODO 或 HTTP&amp;API 查找和发现服务。Nacos 提供对服务的实时的健康检测，阻止向不健康的主机或服务实例发送请求。Nacos  支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测 2 种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量；</li> <li><strong>动态配置服务</strong>：动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。Nacos 提供了一个简洁易用的 UI (控制台样例 Demo) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险；</li> <li><strong>动态 DNS 服务</strong>：动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单 DNS 解析服务。动态 DNS 服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。Nacos 提供了一些简单的 <a href="https://nacos.io/zh-cn/docs/xx" target="_blank" rel="noopener noreferrer">DNS APIs TODO<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 帮助您管理服务的关联域名和可用的 IP:PORT 列表；</li> <li><strong>服务及其元数据管理</strong>：Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</li></ol> <p><strong>小结</strong>：挑重要的来说，一句话总结 Nacos 中的重要功能有两个：服务注册与发现 + 配置中心。</p> <h3 id="nacos-生态如何"><a href="#nacos-生态如何" class="header-anchor">#</a> Nacos 生态如何？</h3> <p>Nacos 几乎支持所有主流语言，其中 Java/Golang/Python 已经支持 Nacos 2.0 长链接协议，能最大限度发挥 Nacos 性能。阿里微服务 DNS（Dubbo+Nacos+Spring-cloud-alibaba/Seata/Sentinel）最佳实践，是 Java 微服务生态最佳解决方案。</p> <h3 id="nacos-组成部分有哪些"><a href="#nacos-组成部分有哪些" class="header-anchor">#</a> Nacos 组成部分有哪些？</h3> <p>Nacos 是由服务端（含页面控制台）和客户端程序（使用 Nacos 的程序）组成的，它里面包含了配置中心列表及管理功能、服务列表及管理功能和权限控制、集群管理等功能。</p> <h3 id="nacos-部署方式有几种"><a href="#nacos-部署方式有几种" class="header-anchor">#</a> Nacos 部署方式有几种？</h3> <p>Nacos 支持 3 种部署模式：</p> <ol><li>单机部署：用于测试和开发环境试用。</li> <li>集群部署：用于生产环境，确保高可用。</li> <li>多集群部署：用于多数据中心场景。</li></ol> <p>Nacos 安装方式有以下 2 种：</p> <ol><li>使用源码编译安装。</li> <li>使用已编译好的安装包进行安装。</li></ol> <h3 id="如何启动-nacos-服务器"><a href="#如何启动-nacos-服务器" class="header-anchor">#</a> 如何启动 Nacos 服务器？</h3> <p>有安装包之后，先解压安装包，然后进入安装包的 bin 目录（cd nacos/bin），如果是测试和开发环境可以使用命令：sh startup.sh -m standalone，启动 Nacos 的单机模式进行使用。</p> <p>等待 Nacos 启动好之后，在浏览器输入：http://localhost:8848/nacos/，进入 Nacos 控制台的登录页面，之后输入默认用户/密码：nacos/nacos 进入管理页面。</p> <p>关闭服务的话 Linux/Unix/Mac 使用命令：sh shutdown.sh，Windows 使用命令：shutdown.cmd 关闭，此命令需要在 nacos/bin 下执行。</p> <h3 id="nacos-单机和集群部署有什么区别吗"><a href="#nacos-单机和集群部署有什么区别吗" class="header-anchor">#</a> Nacos 单机和集群部署有什么区别吗？</h3> <p>除了启动命令和部署个数不同之外，在数据库的依赖上 Nacos 单机和集群部署也是有区别的。</p> <p>Nacos 单机是不依赖任何数据库的，虽然 Nacos 本身需要存储数据，但单机模式 Nacos 使用的是内置的 Derby 数据库，而 Nacos 依赖 MySQL 做数据存储。</p> <h3 id="nacos-配置中心有什么优点"><a href="#nacos-配置中心有什么优点" class="header-anchor">#</a> Nacos 配置中心有什么优点？</h3> <p>配置中心的作用是将本地配置文件云端话，所谓的云端也就是 Nacos 的服务器端，这样既能保证配置文件中的敏感数据不会暴露，同时又提供了实时的修改、查看、回滚和动态刷新配置文件的功能，非常实用。</p> <h3 id="如何实现-nacos-配置项的动态刷新"><a href="#如何实现-nacos-配置项的动态刷新" class="header-anchor">#</a> 如何实现 Nacos 配置项的动态刷新？</h3> <p>在 Nacos 配置中心修改了配置文件，在不重启项目的前提下，可以实时读取到最新的配置内置。Nacos 默认会为所有获取数据成功的 Nacos 的配置项添加了监听功能，在监听到服务端配置发生变化时会实时触发 org.springframework.cloud.context.refresh.ContextRefresher 的 refresh 方法。但如果需要对 Bean 进行动态刷新，需要参照 Spring 和 Spring Cloud 规范，推荐给类添加 @RefreshScope 或 @ConfigurationProperties 注解，就可以实现配置中心的动态刷新功能了。</p> <h3 id="当客户端连接不到-nacos-配置服务时会怎么"><a href="#当客户端连接不到-nacos-配置服务时会怎么" class="header-anchor">#</a> 当客户端连接不到 Nacos 配置服务时会怎么？</h3> <p>Nacos 客户端有一个“配置快照”的功能，当 Nacos 客户端连接不到 Nacos 配置中心（Nacos 服务端）时，会使用本地的配置快照，类似于 Git 中的本地 commit，也类似于缓存，会在适当的时机更新，但是并没有缓存过期（expiration）的概念，当客户端无法连接到 Nacos Server 时，可以使用配置快照显示系统的整体容灾能力。</p> <h3 id="什么是注册中心"><a href="#什么是注册中心" class="header-anchor">#</a> 什么是注册中心？</h3> <p>注册中心是服务实例存储的仓库，也是服务提供者和服务消费者进行交互的桥梁。它主要提供了服务注册和服务发现这两大核心功能。</p> <p>注册中心的特性是：可注册、能发现、高可用。</p> <p>服务提供者将连接信息注册到注册中心，服务消费者去注册中心获取健康的服务提供者地址进行消费（访问），从而实现了服务提供者和服务消费者的解耦。所以注册中心需要包含以下 3 个角色：</p> <ol><li>提供者（Provider）：服务的提供方（被调用方）；</li> <li>消费者（Consumer）：服务的消费方（调用方）；</li> <li>注册中心（Registry）：Nacos 注册中心，服务提供列表、消费关系等数据的存储方。</li></ol> <h3 id="nacos-有几种服务类型"><a href="#nacos-有几种服务类型" class="header-anchor">#</a> Nacos 有几种服务类型？</h3> <p>Nacos 中有两种服务类型：临时实例和永久实例。</p> <ol><li>临时实例只是临时存在于注册中心中，会在服务下线或不可用时被注册中心剔除，临时实例会与注册中心保持心跳，注册中心会在⼀段时间没有收到来自客户端的心跳后会将实例设置为不健康，然后在⼀段时间后进行剔除。</li> <li>永久实例在被删除之前会永久的存在于注册中心，且有可能并不知道注册中心存在，不会主动向注册中心上报心跳，那么这个时候就需要注册中心主动进行探活。</li></ol> <h3 id="说一下-nacos-中的健康检测机制"><a href="#说一下-nacos-中的健康检测机制" class="header-anchor">#</a> 说一下 Nacos 中的健康检测机制？</h3> <p>Nacos 中的健康检测机制是用来检查服务健康状态的，只有健康的节点才会被服务消费端调用，这样才能保证程序稳定、正常的运行。Nacos 中提供了两种健康检测的机制：</p> <ol><li>客户端主动上报（健康状态的）机制。</li> <li>服务器端反向探测（健康状态的）机制。</li></ol> <p>如何理解这两种机制呢？</p> <p>想象⼀下这么⼀个场景，你所在的地区突然发生地质灾害，你被掩盖在废墟下面，搜救队必须要知道你在废墟里面，那么才能对你进行施救。那有什么方法可以让救援队知道你在废墟下面？</p> <ol><li>第⼀种，你在废墟里面大喊 help! help! I am here! ，让搜救队知道你的位置和健康状态。</li> <li>第二种，搜救队使用了他们的专业检查设备，探测到你正埋在废墟下面。</li></ol> <p>以上这两种方法和 Nacos 的两种健康检测机制类似，也就是客户端主动上报机制，是客户端每隔一段时间，主动向 Nacos 服务器端上报自己的健康状况，而服务器端反向探测机制是 Nacos 服务器端来检测客户端是否健康。</p> <p>Nacos 中的健康检测机制不能主动设置，但健康检测机制是和 Nacos 的服务实例类型强相关的。</p> <p>也就是说 Nacos 中的两种服务实例分别对应了两种健康检查机制：</p> <ol><li>临时实例（也可以叫做非持久化实例）：对应的是客户端主动上报机制。</li> <li>永久实例（也可以叫做持久化实例）：服务端反向探测机制。</li></ol> <h3 id="什么是保护阈值"><a href="#什么是保护阈值" class="header-anchor">#</a> 什么是保护阈值？</h3> <p>保护阈值（ProtectThreshold）是为了防止因过多实例故障，导致所有流量全部流入剩余健康实例，继而造成流量压力将剩余健康实例被压垮形成雪崩效应。应将健康保护阈值定义为⼀个 0 到 1 之间的浮点数（它的默认值为 0）。当域名健康实例数占总服务实例数的比例小于该值时，无论实例是否健康，都会将这个（健康或不健康的）实例返回给客户端。这样做虽然损失了⼀部分流量，但是保证了集群中剩余健康实例能正常工作。</p> <p>比如某个服务有 100 个实例，其中 99 个实例都宕机了，只剩下一个健康的实例，这个时候如果把所有的请求都转发到这一个健康实例上就会造成雪崩效应，最终导致业务系统崩溃。</p> <p>为了防止这种极端情况，于是就有了“保护阈值”，保护阈值一旦被触发，那么 Nacos 将会把请求转发给所有服务实例，也就是健康实例+非健康实例，这样可能会损失了⼀部分流量，但能保证集群中剩余的健康实例能正常工作。</p> <h3 id="nacos-有负载均衡吗"><a href="#nacos-有负载均衡吗" class="header-anchor">#</a> Nacos 有负载均衡吗？</h3> <p>Nacos 0.7.0 版本中提供了负载均衡功能，它的负载均衡策略主要有两个：</p> <ol><li>基于权重的负载均衡，权重的值可以由用户来设置和修改</li> <li>负载均衡支持就近访问，服务同地域优先访问</li></ol> <h3 id="nacos-是-ap-模式还是-cp-模式"><a href="#nacos-是-ap-模式还是-cp-模式" class="header-anchor">#</a> Nacos 是 AP 模式还是 CP 模式？</h3> <p>CAP 含义如下：</p> <ol><li>C：Consisteny（一致性），比如数据库是主从模式，一个写库请求进来了，主库完成了写入操作，但是再（从库）同步数据之前，另一个用户查了这条数据，结果没查到，但是也没报错，这就不是强一致性。虽然最终会同步成功，但这是最终一致性的体现。强一致性的体现在于我不管你因为什么没同步成功（可能网络延迟或其他等），只要没同步成功，我这个从库就不能对外提供服务。必须主从数据一致才可以提供服务。</li> <li>A：Availability（可用性），还是上面的例子，就是保证了可用性。因为虽然主从没同步完成，但是我从库照样能提供服务而且及时响应结果。也就是说可用性保证服务可用，而不在乎数据是否一致。</li> <li>P：Partition Tolerance（分区容错性），集群部署了三台服务，挂了一台，其他两台还能继续对外提供服务，这时候我就认为他是没问题的，也就是我能容忍你挂了一台，只要还有服务能对外提供请求即可。所以一般分区容忍性是必须的，一般都需要从 C 和 A 之间做选择。</li></ol> <p>所以 CP 模式既一致性和分区容忍性，而 AP 模式即可用性和分区容忍性。</p> <p>Nacos 注册中心默认是 AP 模式，但同时也支持 CP 模式，所以 Nacos 中包含了 AP 和 CP 两种模式。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">8/23/2025, 5:26:52 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/vuepress-blog/study-notes/back-end/java/collection.html">
        Java集合
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----><!----><canvas id="vuepress-canvas-cursor"></canvas></div></div>
    <script src="/vuepress-blog/assets/js/app.708f652f.js" defer></script><script src="/vuepress-blog/assets/js/2.467e751d.js" defer></script><script src="/vuepress-blog/assets/js/1.cda9c0e5.js" defer></script><script src="/vuepress-blog/assets/js/142.3d30c6ee.js" defer></script><script src="/vuepress-blog/assets/js/59.8ba32256.js" defer></script>
  </body>
</html>
