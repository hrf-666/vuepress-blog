(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{804:function(s,a,t){"use strict";t.r(a);var e=t(5),r=Object(e.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#_1-缓存"}},[s._v("1. 缓存")])]),a("li",[a("a",{attrs:{href:"#_2-数据共享分布式"}},[s._v("2. 数据共享分布式")])]),a("li",[a("a",{attrs:{href:"#_3、分布式锁"}},[s._v("3、分布式锁")])]),a("li",[a("a",{attrs:{href:"#_4、全局id"}},[s._v("4、全局ID")])]),a("li",[a("a",{attrs:{href:"#_5、计数器"}},[s._v("5、计数器")])]),a("li",[a("a",{attrs:{href:"#_6、限流"}},[s._v("6、限流")])]),a("li",[a("a",{attrs:{href:"#_7、位统计"}},[s._v("7、位统计")])]),a("li",[a("a",{attrs:{href:"#_8-时间轴-timeline"}},[s._v("8. 时间轴（Timeline）")])]),a("li",[a("a",{attrs:{href:"#_9-消息队列"}},[s._v("9. 消息队列")])]),a("li",[a("a",{attrs:{href:"#_10、抽奖"}},[s._v("10、抽奖")])]),a("li",[a("a",{attrs:{href:"#_11、点赞、签到、打卡"}},[s._v("11、点赞、签到、打卡")])]),a("li",[a("a",{attrs:{href:"#_12-商品标签"}},[s._v("12 商品标签")])]),a("li",[a("a",{attrs:{href:"#_13、好友关系、用户关注、推荐模型"}},[s._v("13、好友关系、用户关注、推荐模型")])]),a("li",[a("a",{attrs:{href:"#_14-排行榜"}},[s._v("14 .排行榜")])]),a("li",[a("a",{attrs:{href:"#_15-倒排索引"}},[s._v("15 .倒排索引")])]),a("li",[a("a",{attrs:{href:"#_16-显示最新的项目列表"}},[s._v("16 .显示最新的项目列表")])])])]),a("p"),s._v(" "),a("h1",{attrs:{id:"redis-16-个常见使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-16-个常见使用场景"}},[s._v("#")]),s._v(" Redis 16 个常见使用场景")]),s._v(" "),a("h2",{attrs:{id:"_1-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存"}},[s._v("#")]),s._v(" 1. 缓存")]),s._v(" "),a("p",[s._v("DB缓存，减轻DB服务器压力\n提高系统响应\n作为Key-Value形态的内存数据库，Redis 最先会被想到的应用场景便是作为数据缓存。而使用 Redis 缓存数据非常简单，只需要通过string类型将序列化后的对象存起来即可，不过也有一些需要注意的地方：")]),s._v(" "),a("p",[s._v("必须保证不同对象的 key 不会重复，并且使 key 尽量短，一般使用类名（表名）加主键拼接而成。")]),s._v(" "),a("p",[s._v("选择一个优秀的序列化方式也很重要，目的是提高序列化的效率和减少内存占用。")]),s._v(" "),a("p",[s._v("缓存内容与数据库的一致性，这里一般有两种做法：")]),s._v(" "),a("p",[s._v("只在数据库查询后将对象放入缓存，如果对象发生了修改或删除操作，直接清除对应缓存（或设为过期）。\n在数据库新增和查询后将对象放入缓存，修改后更新缓存，删除后清除对应缓存（或设为过期）。")]),s._v(" "),a("h2",{attrs:{id:"_2-数据共享分布式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据共享分布式"}},[s._v("#")]),s._v(" 2. 数据共享分布式")]),s._v(" "),a("p",[s._v("String 类型，因为 Redis 是分布式的独立服务，可以在多个应用之间共享")]),s._v(" "),a("p",[s._v("例如：分布式Session")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("dependency"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("groupId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("org"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("springframework"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("session"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("groupId"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),s._v("artifactId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("spring"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("session"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("data"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),s._v("redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("artifactId"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("dependency"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"_3、分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、分布式锁"}},[s._v("#")]),s._v(" 3、分布式锁")]),s._v(" "),a("p",[s._v("如今都是分布式的环境下java自带的单体锁已经不适用的。在 Redis 2.6.12 版本开始，string的set命令增加了一些参数：")]),s._v(" "),a("p",[s._v("EX：设置键的过期时间（单位为秒）")]),s._v(" "),a("p",[s._v("PX：设置键的过期时间（单位为毫秒）")]),s._v(" "),a("p",[s._v("NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。")]),s._v(" "),a("p",[s._v("XX ：只在键已经存在时，才对键进行设置操作。")]),s._v(" "),a("p",[s._v("由于这个操作是原子性的，可以简单地以此实现一个分布式的锁，例如：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" lock_key locked NX EX "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("如果这个操作返回false，说明 key\n的添加不成功，也就是当前有人在占用这把锁。而如果返回true，则说明得了锁，便可以继续进行操作，并且在操作后通过del命令释放掉锁。并且即使程序因为某些原因并没有释放锁，由于设置了过期时间，该锁也会在 1\n秒后自动释放，不会影响到其他程序的运行。")]),s._v(" "),a("p",[s._v("推荐使用 redisson 第三方库实现分布式锁。\n参考 java分布式锁终极解决方案之 redisson")]),s._v(" "),a("h2",{attrs:{id:"_4、全局id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4、全局id"}},[s._v("#")]),s._v(" 4、全局ID")]),s._v(" "),a("p",[s._v("int类型，incrby，利用原子性")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("incrby userid "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("分库分表的场景，一次性拿一段")]),s._v(" "),a("h2",{attrs:{id:"_5、计数器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5、计数器"}},[s._v("#")]),s._v(" 5、计数器")]),s._v(" "),a("p",[s._v("int类型，incr方法")]),s._v(" "),a("p",[s._v("例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库")]),s._v(" "),a("p",[s._v("计数功能应该是最适合 Redis 的使用场景之一了，因为它高频率读写的特征可以完全发挥 Redis 作为内存数据库的高效。在 Redis 的数据结构中，string、hash和sorted\nset都提供了incr方法用于原子性的自增操作，下面举例说明一下它们各自的使用场景：")]),s._v(" "),a("p",[s._v("如果应用需要显示每天的注册用户数，便可以使用string作为计数器，设定一个名为REGISTERED_COUNT_TODAY的 key，并在初始化时给它设置一个到凌晨 0 点的过期时间，每当用户注册成功后便使用incr命令使该 key 增长\n1，同时当每天凌晨 0 点后，这个计数器都会因为 key 过期使值清零。\n每条微博都有点赞数、评论数、转发数和浏览数四条属性，这时用hash进行计数会更好，将该计数器的 key 设为weibo:weibo_id，hash的 field\n为like_number、comment_number、forward_number和view_number，在对应操作后通过hincrby使hash 中的 field 自增。\n如果应用有一个发帖排行榜的功能，便选择sorted set吧，将集合的 key 设为POST_RANK。当用户发帖后，使用zincrby将该用户 id 的 score 增长 1。sorted\nset会重新进行排序，用户所在排行榜的位置也就会得到实时的更新。")]),s._v(" "),a("h2",{attrs:{id:"_6、限流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6、限流"}},[s._v("#")]),s._v(" 6、限流")]),s._v(" "),a("p",[s._v("int类型，incr方法")]),s._v(" "),a("p",[s._v("以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false")]),s._v(" "),a("h2",{attrs:{id:"_7、位统计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7、位统计"}},[s._v("#")]),s._v(" 7、位统计")]),s._v(" "),a("p",[s._v("String类型的bitcount（1.6.6的bitmap数据结构介绍）")]),s._v(" "),a("p",[s._v("字符是以8位二进制存储的")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("set")]),s._v(" k1 a\nsetbit k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("6")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nsetbit k1 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v("\nget k1\n/* "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("6")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("7")]),s._v(" 代表的a的二进制位的修改\na 对应的ASCII码是97，转换为二进制数据是01100001\nb 对应的ASCII码是98，转换为二进制数据是01100010\n\n因为bit非常节省空间（1 "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[s._v("MB")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("8388608")]),s._v(" bit），可以用来做大数据量的统计。\n*/\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("参考 "),a("a",{attrs:{href:"https://blog.csdn.net/agonie201218/article/details/107161106",target:"_blank",rel:"noopener noreferrer"}},[s._v("使用Redis的bitmaps统计用户留存率、活跃用户"),a("OutboundLink")],1)]),s._v(" "),a("p",[a("a",{attrs:{href:"https://blog.csdn.net/agonie201218/article/details/108988577",target:"_blank",rel:"noopener noreferrer"}},[s._v("用户日活月活怎么统计 - Redis HyperLogLog 详解"),a("OutboundLink")],1)]),s._v(" "),a("h2",{attrs:{id:"_8-时间轴-timeline"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-时间轴-timeline"}},[s._v("#")]),s._v(" 8. 时间轴（Timeline）")]),s._v(" "),a("p",[s._v("list作为双向链表，不光可以作为队列使用。如果将它用作栈便可以成为一个公用的时间轴。当用户发完微博后，都通过lpush将它存放在一个 key 为LATEST_WEIBO的list中，之后便可以通过lrange取出当前最新的微博。")]),s._v(" "),a("h2",{attrs:{id:"_9-消息队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-消息队列"}},[s._v("#")]),s._v(" 9. 消息队列")]),s._v(" "),a("p",[s._v("Redis 中list的数据结构实现是双向链表，所以可以非常便捷的应用于消息队列（生产者 / 消费者模型）。消息的生产者只需要通过lpush将消息放入\nlist，消费者便可以通过rpop取出该消息，并且可以保证消息的有序性。如果需要实现带有优先级的消息队列也可以选择sorted set。而pub/sub功能也可以用作发布者 / 订阅者模型的消息。无论使用何种方式，由于 Redis\n拥有持久化功能，也不需要担心由于服务器故障导致消息丢失的情况。")]),s._v(" "),a("p",[s._v("List提供了两个阻塞的弹出操作：blpop/brpop，可以设置超时时间")]),s._v(" "),a("p",[s._v("blpop：blpop key1 timeout 移除并获取列表的第一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\nbrpop：brpop key1 timeout 移除并获取列表的最后一个元素，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。\n上面的操作。其实就是java的阻塞队列。学习的东西越多。学习成本越低")]),s._v(" "),a("p",[s._v("队列：先进先除：rpush blpop，左头右尾，右边进入队列，左边出队列\n栈：先进后出：rpush brpop")]),s._v(" "),a("h2",{attrs:{id:"_10、抽奖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10、抽奖"}},[s._v("#")]),s._v(" 10、抽奖")]),s._v(" "),a("p",[s._v("利用set结构的无序性,通过 Spop（ Redis Spop 命令用于移除集合中的指定 key 的一个或多个随机元素，移除后会返回移除的元素。 ） 随机获得值")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SADD myset "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"one"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nredis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SADD myset "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"two"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nredis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SADD myset "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"three"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\nredis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SPOP myset\n"),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"one"')]),s._v("\nredis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SMEMBERS myset\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"three"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"two"')]),s._v("\n   redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SADD myset "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"four"')]),s._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n   redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SADD myset "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"five"')]),s._v("\n   "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("integer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("\n   redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SPOP myset "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"five"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"four"')]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"two"')]),s._v("\n   redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" SMEMBERS myset\n"),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"three"')]),s._v("\n   redis"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br")])]),a("h2",{attrs:{id:"_11、点赞、签到、打卡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11、点赞、签到、打卡"}},[s._v("#")]),s._v(" 11、点赞、签到、打卡")]),s._v(" "),a("p",[s._v("假如上面的微博ID是t1001，用户ID是u3001")]),s._v(" "),a("p",[s._v("用 like:t1001 来维护 t1001 这条微博的所有点赞用户")]),s._v(" "),a("ol",[a("li",[s._v("点赞了这条微博：sadd like:t1001 u3001")]),s._v(" "),a("li",[s._v("取消点赞：srem like:t1001 u3001")]),s._v(" "),a("li",[s._v("是否点赞：sismember like:t1001 u3001")]),s._v(" "),a("li",[s._v("点赞的所有用户：smembers like:t1001")]),s._v(" "),a("li",[s._v("点赞数：scard like:t1001\n是不是比数据库简单多了。")])]),s._v(" "),a("h2",{attrs:{id:"_12-商品标签"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-商品标签"}},[s._v("#")]),s._v(" 12 商品标签")]),s._v(" "),a("p",[s._v("老规矩，用 tags:i5001 来维护商品所有的标签。")]),s._v(" "),a("ol",[a("li",[s._v("sadd tags:i5001 画面清晰细腻")]),s._v(" "),a("li",[s._v("sadd tags:i5001 真彩清晰显示屏")]),s._v(" "),a("li",[s._v("sadd tags:i5001 流程至极")])]),s._v(" "),a("h2",{attrs:{id:"_13、好友关系、用户关注、推荐模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13、好友关系、用户关注、推荐模型"}},[s._v("#")]),s._v(" 13、好友关系、用户关注、推荐模型")]),s._v(" "),a("p",[s._v("这个场景最开始是是一篇介绍微博 Redis 应用的 PPT 中看到的，其中提到微博的 Redis 主要是用在在计数和好友关系两方面上，当时对好友关系方面的用法不太了解，后来看到《Redis 设计与实现》中介绍到作者最开始去使用 Redis\n便是希望能通过set解决传统数据库无法快速计算集合中交集这个功能。后来联想到微博当前的业务场景，确实能够以这种方式实现，所以姑且猜测一下：")]),s._v(" "),a("p",[s._v("对于一个用户 A，将它的关注和粉丝的用户 id 都存放在两个 set 中：")]),s._v(" "),a("ol",[a("li",[s._v("A:follow：存放 A 所有关注的用户 id")]),s._v(" "),a("li",[s._v("A:follower：存放 A 所有粉丝的用户 id")])]),s._v(" "),a("p",[s._v("那么通过sinter命令便可以根据A:follow和A:follower的交集得到与 A 互相关注的用户。当 A 进入另一个用户 B 的主页后，A:follow和B:follow的交集便是 A 和 B 的共同专注，A:follow和B:\nfollower的交集便是 A 关注的人也关注了 B。")]),s._v(" "),a("p",[s._v("举例\nfollow 关注 fans 粉丝")]),s._v(" "),a("p",[s._v("相互关注：")]),s._v(" "),a("ol",[a("li",[a("p",[s._v("sadd 1:follow 2")])]),s._v(" "),a("li",[a("p",[s._v("sadd 2:fans 1")])]),s._v(" "),a("li",[a("p",[s._v("sadd 1:fans 2")])]),s._v(" "),a("li",[a("p",[s._v("sadd 2:follow 1\n我关注的人也关注了他(取交集)：")])]),s._v(" "),a("li",[a("p",[s._v("sinter 1:follow 2:fans\n可能认识的人：")])]),s._v(" "),a("li",[a("p",[s._v("用户1可能认识的人(差集)：sdiff 2:follow 1:follow")])]),s._v(" "),a("li",[a("p",[s._v("用户2可能认识的人：sdiff 1:follow 2:follow")])])]),s._v(" "),a("h2",{attrs:{id:"_14-排行榜"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-排行榜"}},[s._v("#")]),s._v(" 14 .排行榜")]),s._v(" "),a("p",[s._v("使用sorted set(有序set)\n和一个计算热度的算法便可以轻松打造一个热度排行榜，zrevrangebyscore可以得到以分数倒序排列的序列，zrank可以得到一个成员在该排行榜的位置（是分数正序排列时的位置，如果要获取倒序排列时的位置需要用zcard-zrank）。")]),s._v(" "),a("p",[s._v("id 为6001 的新闻点击数加1：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("zincrby hotNews:20190926 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" n6001\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("获取今天点击最多的15条：")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("zrevrange hotNews:20190926 "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("15")]),s._v(" withscores\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"_15-倒排索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-倒排索引"}},[s._v("#")]),s._v(" 15 .倒排索引")]),s._v(" "),a("p",[s._v("倒排索引是构造搜索功能的最常见方式，在 Redis 中也可以通过set进行建立倒排索引，这里以简单的拼音 + 前缀搜索城市功能举例：")]),s._v(" "),a("p",[s._v("假设一个城市北京，通过拼音词库将北京转为beijing，再通过前缀分词将这两个词分为若干个前缀索引，有：北、北京、b、be…beijin和beijing。将这些索引分别作为set的 key（例如:index:北）并存储北京的\nid，倒排索引便建立好了。接下来只需要在搜索时通过关键词取出对应的set并得到其中的 id 即可。")]),s._v(" "),a("h2",{attrs:{id:"_16-显示最新的项目列表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-显示最新的项目列表"}},[s._v("#")]),s._v(" 16 .显示最新的项目列表")]),s._v(" "),a("p",[s._v("比如说，我们的一个Web应用想要列出用户贴出的最新20条评论。在最新的评论边上我们有一个“显示全部”的链接，点击后就可以获得更多的评论。")]),s._v(" "),a("p",[s._v("每次新评论发表时，我们会将它的ID添加到一个Redis列表。可以限定列表的长度为5000")]),s._v(" "),a("div",{staticClass:"language-bash line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[s._v("LPUSH latest.comments\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("在Redis中我们的最新ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在超出了这个范围的时候，才需要去访问数据库。")]),s._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://blog.csdn.net/agonie201218/article/details/123640871",target:"_blank",rel:"noopener noreferrer"}},[s._v("原文链接"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=r.exports}}]);